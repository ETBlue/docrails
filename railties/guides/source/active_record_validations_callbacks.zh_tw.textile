h2. Active Record 的驗證 (Validations) 與回呼 (Callbacks)

這一章說明如何 ??? hook into ??? Active Record 物件的生命週期：在物件進入資料庫之前驗證它的狀態，以及，在物件生命週期的特定時間點，執行自訂的操作。

讀完本篇，您會：

* 了解 Active Record 物件的生命週期 (life cycle)
* 使用內建的 Active Record 驗證輔助工具 (validation helpers)
* 打造您自訂的驗證方法
* 處理驗證過程中所產生的錯誤訊息
* 在物件生命週期期間，會發生一些事件，您將學會針對這些事件，撰寫回呼方法 (callback methods) 。
* 在回呼 (callbacks) 之間，有些共通的行為，您將學會針對這些行為，撰寫特殊類別 (special classes) ，以封裝 (encapsulate) 它們。 
* 有些事件 (events) ，並沒有定義在原來的類別中，您將學會針對這些事件，建立觀測器 (observers)，以便回應它們。

endprologue.

h3. 物件生命週期 (Object Life Cycle)

Rails 正常操作下，會產生一些物件，也會更新、銷毀它們。為此，Active Record 提供了 <em>object life cycle</em> 內的 hooks，讓您可以操控程式、操控資料。

其中，驗證 (validations) 是用來確保只有有效的資料，被存到資料庫裡面。而回呼 (callbacks) 和觀測器 (observers) ，則是在物件狀態變化之前、或變化之後，觸發相關的邏輯。

h3. 驗證的概觀 (Validations Overview)

深入 Rails 的驗證 (validations) 細節前，先了解一下驗證扮演的角色。

h4. 為什麼要驗證 (Why Use Validations) ？

驗證 (validations) 的用意，是要確保資料庫裡，只有有效資料 (valid data) 才存進去。比方說，您的應用程式，可能要確定每個使用者，都提供有效的電子郵件地址、和郵寄地址等。

在資料存進資料庫前，有幾個驗證的方法，包括：原生的資料庫約束 (native database constraints) 、客戶端驗證 (client-side validations) 、控制器層級的驗證 (controller-level validations) 、以及模型層級的驗證 (model-level validations)。

* 資料庫約束 (database constraints) 或者是預存程序 (stored procedures) ，這些驗證機制，要依賴特定的資料庫系統，所以測試和維護會比較難。不過，如果資料庫會去給別的應用程式用，那在資料庫層做約束可能就是不錯的作法。另外，資料庫層級的驗證可以很安全的處理一些事情，像是在重度使用的資料表中，確保唯一值 (uniqueness) 之類的。這些事情，如果用其他的方法，會比較難實作。
* 客戶端的驗證 (client-side validations) 雖然可以用，但單單用這個的話通常不太可靠。如果用 JavaScript 來做，要是使用者的瀏覽器把 JavaScript 關掉，那驗證就被略過了。不過畢竟，客戶端驗證可以給使用者很即時的回饋，所以，要是能跟其他驗證手法併用，那倒是挺方便的。
* 控制器層級的驗證 (controller-level validations) ，也是可以用，但常常很笨重，不好測試跟維護。不管怎樣，"keep your controllers skinny":http://weblog.jamisbuck.org/2006/10/18/skinny-controller-fat-model 總是好的，長遠的說，可以讓程式用起來很愉快。
* 模型層級的驗證 (model-level validations) ，是最佳作法。這種驗證方式，不用去管資料庫是哪個系統，也不會被使用者略過，測試起來很方便，也容易維護。為了方便大家使用 model 層級的驗證，Rails 針對常用功能，內建了輔助工具，當然，您也可以撰寫自己的驗證方法。

h4. 什麼時候會發生驗證 (When Does Validation Happen) ？

Active Record 類別底下，有兩種物件：一種是跟某筆資料對應的，另一種是沒有跟資料對應的。當您用 +new+ 之類的方法，建立了一個新物件，此時，它還不屬於資料庫。等到您呼叫那個物件的 +save+ 方法，它才會被存入適當的資料表中。至於物件目前是否已存入資料庫，則是用 Active Record 的實體方法 (instance method) +new_record?+ 來確認。簡單舉例，這裡有個 Active Record 底下的類別：

<ruby>
class Person < ActiveRecord::Base
end
</ruby>

從 +rails console+ 的輸出結果，可以看出它的運作方式：

<shell>
>> p = Person.new(:name => "John Doe")
=> #<Person id: nil, name: "John Doe", created_at: nil, :updated_at: nil>
>> p.new_record?
=> true
>> p.save
=> true
>> p.new_record?
=> false
</shell>

一筆新記錄 (record) 的新增與儲存，會對資料庫送出一個 SQL 的 +INSERT+ 操作 (operation) 。現有記錄的更新則送出 +UPDATE+ 操作。通常送命令到資料庫前，會先做驗證，任一個驗證失敗的話，這個物件就標記為無效 (marked as invalid) ，於是 Active Record 不會執行 +INSERT+ 或 +UPDATE+ ，無效的物件也就不會存進資料庫。您也可以針對物件新增、儲存、更新，自訂專屬的驗證功能。

CAUTION: 在資料庫裡面，要改變物件的狀態 (state) ，有很多種方法都能做到，這些方法中，有些會觸發驗證機制，有些則不會。也就是說，不注意的話，是有可能把無效狀態 (invalid state) 的物件，存到資料庫裡去的。

下面列出的方法，會觸發驗證，只有驗證合格的物件才會存入資料庫：

* +create+
* +create!+
* +save+
* +save!+
* +update+
* +update_attributes+
* +update_attributes!+

尾巴附有一個驚嘆號的版本 (bang versions) 像是 +save!+ ，會在這筆紀錄 invalid 的時候丟出例外 (raise an exception) 。沒有驚嘆號的 (non-bang versions) 則不會丟出例外。其中， +save+ 跟 +update_attributes+ 會傳回 +false+ ，而 +create+ 跟 +update+ 則單純的傳回物件本身。

h4. 略過驗證 (Skipping Validations)

下面列出的方法會略過驗證，不管物件是否有效，都會將它存到資料庫中。所以，要小心使用。

* +decrement!+
* +decrement_counter+
* +increment!+
* +increment_counter+
* +toggle!+
* +update_all+
* +update_attribute+
* +update_counters+

對了，如果把 +:validate => false+ 當作引數 (argument) 傳入的話， +save+ 也是可以略過驗證的。這個技巧也是要小心使用。

* +save(:validate => false)+

h4. +valid?+ 與 +invalid?+ 檢查是否有錯誤訊息

Rails 在確認物件是否有效的時候，是用 +valid?+ 方法，您平常也可以自己把 +valid?+ 拿來用。它會觸發驗證，如果驗證完，沒有錯誤訊息附加到物件上的話，就傳回真值 (true) ，反之，有錯誤訊息的話，就是假值 (false) 。

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name
end

Person.create(:name => "John Doe").valid? # => true
Person.create(:name => nil).valid? # => false
</ruby>

Active Record 在執行驗證的時候，任何的錯誤訊息，都可以用 +errors+ 這個實體方法 (instance method) 來存取 (accessed) 。驗證結束後，如果這個集合 (collection) 仍然是空的，那在定義上，這個物件就會被認為是有效的 (valid) 。

用 +new+ 實體化 (instantiated) 出來的物件，即使它在技術上是無效 (invalid) 的，也不會回報錯誤訊息，因為，執行 +new+ 的時候，並不會進行驗證。

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name
end

>> p = Person.new
=> #<Person id: nil, name: nil>
>> p.errors
=> {}

>> p.valid?
=> false
>> p.errors
=> {:name=>["can't be blank"]}

>> p = Person.create
=> #<Person id: nil, name: nil>
>> p.errors
=> {:name=>["can't be blank"]}

>> p.save
=> false

>> p.save!
=> ActiveRecord::RecordInvalid: Validation failed: Name can't be blank

>> Person.create!
=> ActiveRecord::RecordInvalid: Validation failed: Name can't be blank
</ruby>

+invalid?+ 純粹是 +valid?+ 的相反， +invalid?+ 會觸發驗證，如果有任何錯誤訊息加到物件上，就傳回真值 (true) ， 反之則是假值 (false) 。

h4(#validations_overview-errors). +errors[]+ 屬性內，錯誤訊息的陣列集合

對於物件的某個屬性 (attribute) ，要確認是否有效 (valid) 的話，可以用 +errors[:attribute]+ ，它會傳回一個陣列 (array) ，裡面有這個屬性的全部的錯誤訊息 (attribute errors) 。如果，這個屬性沒有任何錯誤訊息，那就會傳回空的陣列。

這個方法，要在驗證執行過 _之後_ 才能使用，因為，它只會檢查錯誤訊息的集合 (errors collection) ，而不會去觸發驗證本身。這跟上面提過的 +ActiveRecord::Base#invalid?+ 方法，是不一樣的，因為它不會去確認物件整體上的有效性 (validity) ，它只是去看這個物件的個別屬性，有沒有錯誤訊息在裡面而已。

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name
end

>> Person.new.errors[:name].any? # => false
>> Person.create.errors[:name].any? # => true
</ruby>

關於驗證的錯誤訊息 (validation errors) ，之後的 "Working with Validation Errors":#working-with-validation-errors 章節會再深入解釋。現在，讓我們回頭看看 Rails 內建的驗證輔助工具 (validation helpers) 。

h3. 驗證輔助工具 (Validation Helpers)

Active Record 預先定義好許多驗證輔助工具，您可以在類別定義 (class definition) 裡面，直接使用它們。這些輔助工具，有共通的驗證規則，每次，一個驗證失敗時，就會在該物件的 +errors+ 集合中，加入一條錯誤訊息，這個訊息，則會跟當時正在驗證的欄位 (field) 相關連。

每個輔助工具，可以接收 (accepts) 多個屬性名稱 (attribute names) ，要幾個都可以。所以，只要用一行程式碼，就可以把同一種驗證方式，套用到好幾個不同的屬性上面。

輔助工具都可接收 +:on+ 跟 +:message+ 選項 (options) ，這些選項，會定義驗證該何時執行，以及，如果驗證失敗的話，該加什麼訊息到 +errors+ 集合中, respectively 。選項 +:on+ 的作用，是將一個值 +:save+ （預設），或者 +:create+ ，或者 +:update+ 。至於選項 +:message+ 的作用，則是自訂錯誤訊息，如果，沒有自訂 +:message+ ，就會採用預設的，反正，每個驗證輔助工具，都有預設的訊息可以用。底下讓我們一個一個來看。

h4. +validates_acceptance_of+ 確定使用者已經接受

當使用者送出表格 (form submitted) 時，針對使用者介面中的核取方塊 (checkbox) ，驗證它有沒有勾選。會用到的地方，通常是應用程式的服務條款 (terms of service) ，要使用者確認「我同意」、「我已閱讀」之類的。這種驗證，幾乎都是網路應用程式 (web applications) 在用。這個 'acceptance （是否已接受）' 不用記在資料庫裡，所以，沒有對應的欄位 (field) 也沒關係，輔助工具會建立一個虛擬的屬性 (virtual attribute) 來應付。

<ruby>
class Person < ActiveRecord::Base
  validates_acceptance_of :terms_of_service
end
</ruby>

+validates_acceptance_of+ 預設的錯誤訊息是 "_must be accepted_" 。

+validates_acceptance_of+ 可以接收 +:accept+ 選項，決定什麼值代表 acceptance （已接受），預設的值是 "1" ，您要改掉它也可以。

<ruby>
class Person < ActiveRecord::Base
  validates_acceptance_of :terms_of_service, :accept => 'yes'
end
</ruby>

h4. +validates_associated+ 驗證其他有關連的模型

如果您的 model ，跟其他 models 有關連 (associations) ，而這些相關的 models 也需要驗證，那麼，就需要使用這個輔助工具了。使用 +validates_associated+ 後，當您儲存物件時，每一個跟它相關的物件，都會呼叫 +valid?+ 方法。

<ruby>
class Library < ActiveRecord::Base
  has_many :books
  validates_associated :books
end
</ruby>

所有的資料庫關聯類型 (association types) ，都可以使用這種驗證。

CAUTION: 不要在一個資料庫關聯的兩端，同時使用 +validates_associated+ ，因為，它們會一直互相呼叫，最後沒完沒了，停不下來。

+validates_associated+ 預設的錯誤訊息是 "_is invalid_" 。每個相關連的物件 (associated object) 都有自己的 +errors+ 集合，自己的錯誤訊息，只會出現在自己的集合裡面，不會跑到對方的模型 (calling model) 裡面。

h4. +validates_confirmation_of+ 檢查使用者的再次確認

如果有兩個文字欄位 (text fields) ，必須收到一模一樣的內容，就會用到這個驗證，比方說，要使用者再確認一次 email address 或是 password 的時候。這個驗證功能，會建立一個虛擬屬性 (virtual attribute) ，虛擬屬性的名稱，就是把那個需要確認的欄位的名稱，尾巴後面再加上 "_confirmation" 。

<ruby>
class Person < ActiveRecord::Base
  validates_confirmation_of :email
end
</ruby>

使用這個驗證的時候，在視圖模板 (view template) 中，可以寫成：

<erb>
<%= text_field :person, :email %>
<%= text_field :person, :email_confirmation %>
</erb>

上面的檢查，只有在 +email_confirmation+ 不是空值 +nil+ 的時候，才會執行，所以，要 require confirmation 的話，要事先確認驗證屬性 (confirmation attribute) 是不是存在 (presence check) 。關於這點，後面會在 +validates_presence_of+ 講到。

<ruby>
class Person < ActiveRecord::Base
  validates_confirmation_of :email
  validates_presence_of :email_confirmation
end
</ruby>

+validates_confirmation_of+ 預設的錯誤訊息是 "_doesn't match confirmation_" 。

h4. +validates_exclusion_of+ 確定屬性的值不在指定清單內

確認該屬性的值，沒有在指定的 set 中出現。這個 set ，可以是任何一個可逐一列舉的 (enumerable) 物件。

<ruby>
class Account < ActiveRecord::Base
  validates_exclusion_of :subdomain, :in => %w(www),
    :message => "Subdomain %{value} is reserved."
end
</ruby>

+validates_exclusion_of+ 有個 +:in+ 的選項，會接收一組值，這組值，也就是被驗證的屬性，所不該接受的值。+:in+ 選項有個別名 (alias) 叫做 +:within+ ，功能是一樣的。上面的範例用 +:message+ 選項??? 來表現如何 include 屬性的值 ???。

+validates_exclusion_of+ 預設的錯誤訊息是 "_is reserved_" 。

h4. +validates_format_of+ 檢查屬性值的格式

這個工具，會測試屬性的值，是否符合 +:with+ 選項所指定的常規表示式 (regular expression) 。

<ruby>
class Product < ActiveRecord::Base
  validates_format_of :legacy_code, :with => /\A[a-zA-Z]+\z/,
    :message => "Only letters allowed"
end
</ruby>

+validates_format_of+ 預設的錯誤訊息是 "_is invalid_" 。

h4. +validates_inclusion_of+ 確定屬性的值在指定清單內

確認該屬性的值，有被包括在指定的 set 裡面，這個 set 可以是任何 enumerable 物件。

<ruby>
class Coffee < ActiveRecord::Base
  validates_inclusion_of :size, :in => %w(small medium large),
    :message => "%{value} is not a valid size"
end
</ruby>

+validates_inclusion_of+ 有個 +:in+ 選項，會接收一組值，就是被驗證的屬性，所能夠接受的值。 +:in+ 選項有個別名 (alias) 叫做 +:within+ ，功能是相同的。上面的範例用 +:message+ 選項來表現如何 include 屬性的值。

+validates_inclusion_of+ 預設的錯誤訊息是 "_is not included in the list_" 。

h4. +validates_length_of+ 確定長度在指定範圍內

驗證屬性值的長度。這個工具有多種選項 (options) ，所以，您有許多方法，可以指定長度限制 (length constraints) ：

<ruby>
class Person < ActiveRecord::Base
  validates_length_of :name, :minimum => 2
  validates_length_of :bio, :maximum => 500
  validates_length_of :password, :in => 6..20
  validates_length_of :registration_number, :is => 6
end
</ruby>

可用的選項，包括：

* +:minimum+ - 屬性的值不能比指定長度短。
* +:maximum+ - 屬性的值不能比指定長度長。
* +:in+ (or +:within+) - 屬性的值的長度，要在某個區間 (interval) 之內。所以，這個選項的值，必須是一個範圍 (range) 。
* +:is+ - 屬性的值的長度，要跟指定的長度相等。

不同類型的長度驗證，預設的錯誤訊息，也各自不同。要自訂錯誤訊息，可以用 +:wrong_length+ 、 +:too_long+ 、+:too_short+ 選項，搭配 <tt>%{count}</tt> 做為 placeholder ，留給跟長度限制有關的數字。同樣的，您可以用 +:message+ 選項來自訂錯誤訊息。

<ruby>
class Person < ActiveRecord::Base
  validates_length_of :bio, :maximum => 1000,
    :too_long => "%{count} characters is the maximum allowed"
end
</ruby>

預設狀態下，此工具會計算字元 (characters) ，不過，要用別的方式 split the value 的話，您可以用 +:tokenizer+ 選項：

<ruby>
class Essay < ActiveRecord::Base
  validates_length_of :content,
    :minimum   => 300,
    :maximum   => 400,
    :tokenizer => lambda { |str| str.scan(/\w+/) },
    :too_short => "must have at least %{count} words",
    :too_long  => "must have at most %{count} words"
end
</ruby>

+validates_length_of+ 輔助工具，別名叫做 +validates_size_of+ 。

h4. +validates_numericality_of+ 確保屬性只包括數值

驗證您的屬性只包含數字值 (numeric values) 。預設是符合 match an optional sign 後面接 followed by 一個整數 (integral) 或浮點數 (floating point number) 。如果只想允許整數，把 +:only_integer+ 設定為 true 就可以了。

如果 +:only_integer+ 設為 +true+ ，會用這個常規表示式

<ruby>
/\A[+-]?\d+\Z/
</ruby>

來驗證屬性的值。反之，如果沒設定，則會嘗試用 +Float+ 來把值轉換成數字。

WARNING. 上面的常規表示式，允許 ??? 字元 (trailing newline character) 。

<ruby>
class Player < ActiveRecord::Base
  validates_numericality_of :points
  validates_numericality_of :games_played, :only_integer => true
end
</ruby>

除了 +:only_integer+ 之外， +validates_numericality_of+ 還接受下列這些選項，來限制允許的值 (acceptable values) ：

* +:greater_than+ - 必須比這個值還大。預設的錯誤訊息是 "_must be greater than %{count}_" 。
* +:greater_than_or_equal_to+ - 必須大於或等於這個值。預設的錯誤訊息是 "_must be greater than or equal to %{count}_" 。
* +:equal_to+ - 必須等於這個值。預設的錯誤訊息是 "_must be equal to %{count}_" 。
* +:less_than+ - 必須小於這個值。預設的錯誤訊息是 "_must be less than %{count}_" 。
* +:less_than_or_equal_to+ - 必須小於或等於這個值。預設的錯誤訊息是 "_must be less than or equal to %{count}_" 。
* +:odd+ - 如果設定為 true ，則被驗證的值必須是奇數???。預設的錯誤訊息是 "_must be odd_" 。
* +:even+ - 如果設定為 true ，則被驗證的值必須是偶數???。預設的錯誤訊息是 "_must be even_" 。

+validates_numericality_of+ 預設的錯誤訊息是 "_is not a number_" 。

h4. +validates_presence_of+ 確定屬性是存在的

驗證指定的屬性不是空的。此工具使用 +blank?+ 方法，去檢查屬性值是否為 +nil+ 或者空字串 (blank string) ，所謂空字串指的是沒有內容 (empty) 、或者由空白 (whitespace) 組成的字串。

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name, :login, :email
end
</ruby>

如果，要確認資料庫關聯 (association) 的存在，那要測試的，是存不存在 map the association 的外部鍵 (foreign key) ，而不是相關連的物件 (associated object) 本身。

<ruby>
class LineItem < ActiveRecord::Base
  belongs_to :order
  validates_presence_of :order_id
end
</ruby>

??? 由於 +false.blank?+ 是 true ，Since +false.blank?+ is true, ??? 要驗證布林欄位 (boolean field) 的存在，必須寫成 +validates_inclusion_of :field_name, :in => [true, false]+ 。

+validates_presence_of+ 預設的錯誤訊息是 "_can't be empty_" 。

h4. +validates_uniqueness_of+ 確保屬性的值是唯一的

在儲存物件的前一刻，驗證屬性的值，以確定它是唯一的。這個工具，並不會在資料庫中建立唯一限定 (uniqueness constraint) ，所以，可能會有兩個不同 database connections ，在同一個欄，存入了兩筆一樣的記錄 (records) 。要避免這個狀況，您必須為資料庫做一個 unique index 。

<ruby>
class Account < ActiveRecord::Base
  validates_uniqueness_of :email
end
</ruby>

這個驗證的運作方式，是在 model 的資料表內，執行一個 SQL 查詢 (query) 。如此，會在現有的記錄 (record) 裡面，針對指定的屬性，搜尋相同的值。

要把唯一值檢查 (uniqueness check) 加上其他檢查條件的話，需要用到一些額外的屬性。這些屬性，可以用 +:scope+ 選項來指定：

<ruby>
class Holiday < ActiveRecord::Base
  validates_uniqueness_of :name, :scope => :year,
    :message => "should happen once per year"
end
</ruby>

另外，還有個 +:case_sensitive+ 選項，可以設定唯一值的檢查是否要分大小寫 (case sensitive) 。預設是 true 。

<ruby>
class Person < ActiveRecord::Base
  validates_uniqueness_of :name, :case_sensitive => false
end
</ruby>

WARNING. 有些資料庫，??? 設定成不管怎樣，都會執行不分大小寫的搜尋 are configured to perform case-insensitive searches anyway.

+validates_uniqueness_of+ 預設的錯誤訊息是 "_has already been taken_" 。

h4. +validates_with+ 用另外的類別來做驗證

把記錄 (record) 轉交給另一個獨立的類別 (separate class) 來驗證。

<ruby>
class Person < ActiveRecord::Base
  validates_with GoodnessValidator
end

class GoodnessValidator < ActiveRecord::Validator
  def validate
    if record.first_name == "Evil"
      record.errors[:base] << "This person is evil"
    end
  end
end
</ruby>

+validates_with+ 會用一個或多個類別，來進行驗證。它沒有預設的錯誤訊息，所以，必須用手動 (manual) 的方式，在 validator 類別的定義裡面，把錯誤訊息加入該筆記錄 (record) 的錯誤訊息集合 (errors collection) 中。

validator 類別預設有兩個屬性：

* +record+ - 要驗證的那筆記錄 (record)
* +options+ - 已傳給 +validates_with+ 的額外選項 (extra options)

??? +validates_with+ 有 +:if+ 、+:unless+ 、+:on+ 這三個選項可用，這一點，就跟其他驗證方式一樣。如果有傳入其他選項，則會以 +options+ 的方式，送到 validator 類別去：???

<ruby>
class Person < ActiveRecord::Base
  validates_with GoodnessValidator, :fields => [:first_name, :last_name]
end

class GoodnessValidator < ActiveRecord::Validator
  def validate
    if options[:fields].any?{|field| record.send(field) == "Evil" }
      record.errors[:base] << "This person is evil"
    end
  end
end
</ruby>

h4. +validates_each+ 用區塊進行自訂的驗證

按照區塊 (block) 裡的程式碼，對屬性 (attributes) 做驗證。這個工具，沒有定義任何驗證功能，您要自己用區塊 (block) 來撰寫驗證，然後，每一個傳給 (passed to) +validates_each+ 的屬性，都會根據您的區塊內容來做測試。下面示範，希望 names 跟 surnames 不是小寫開頭：

<ruby>
class Person < ActiveRecord::Base
  validates_each :name, :surname do |model, attr, value|
    model.errors.add(attr, 'must start with upper case') if value =~ /\A[a-z]/
  end
end
</ruby>

區塊接收了三樣東西：模型、屬性名稱、屬性的值。在區塊內，可以做任何您想做的驗證。要是驗證失敗，可以在 model 裡加入錯誤訊息，讓它變成無效的 (invalid) 。

h3. 共通的驗證選項 (Common Validation Options)

有些共通的選項 (options) ，所有的驗證輔助工具都能用，下面介紹除了 +:if+ 跟 +:unless+ 之外的共通選項（這兩個選項，會另外在 "條件式驗證 (Conditional Validation)":#conditional-validation 的部份討論）。

h4. +:allow_nil+ 允許 nil 值

+:allow_nil+ 選項，在被驗證的值是 +nil+ 的時候，會略過驗證。在 +validates_presence_of+ 工具裡面，使用 +:allow_nil+ 選項的話，就可以允許 +nil+ 值，不過，其他任何的 +blank?+ 值還是一樣會被拒絕 (rejected) 。

<ruby>
class Coffee < ActiveRecord::Base
  validates_inclusion_of :size, :in => %w(small medium large),
    :message => "%{value} is not a valid size", :allow_nil => true
end
</ruby>

h4. +:allow_blank+ 允許 blank 值

+:allow_blank+ 有點類似 +:allow_nil+ ，但允許的範圍更廣。 +:allow_blank+ 會在屬性值是 +blank?+ 的時候，也讓驗證通過，像是 +nil+ 或是空字串 (empty string) 之類的。

<ruby>
class Topic < ActiveRecord::Base
  validates_length_of :title, :is => 5, :allow_blank => true
end

Topic.create("title" => "").valid? # => true
Topic.create("title" => nil).valid? # => true
</ruby>

h4. +:message+ 自訂錯誤訊息

+:message+ 選項用來自訂訊息，此訊息會在驗證失敗的時候，加到 +errors+ 集合 (collection) 裡面。沒設定此選項時， Active Record 會採用驗證輔助工具 (validation helpers) 原本就有的、各自的預設錯誤訊息。

h4. +:on+ 在特定的時候進行驗證

+:on+ 選項可以設定驗證該在何時發生。所有內建的驗證輔助工具，預設的行為，是在儲存的時候，包括新增一筆記錄、以及更新記錄 (record) 時，都會執行驗證。您可以用 +:on => :create+ 指定只要在新增的時候驗證就好，或者，用 +:on => :update+ 設定只要在更新的時候驗證。

<ruby>
class Person < ActiveRecord::Base
  # 在更新 email 資料的時候，輸入跟先前一樣的 email 值，是可以的
  validates_uniqueness_of :email, :on => :create

  # 在新增年齡資料的時候，輸入不是數字 (non-numerical) 的值，是可以的
  validates_numericality_of :age, :on => :update

  # 預設的狀況（新增、更新，兩種狀況都驗證）
  validates_presence_of :name, :on => :save
end
</ruby>

h3. 條件式驗證 (Conditional Validation)

有時候，需要在滿足某些陳述 (predicate) 的狀況下，才對物件做驗證。此時，就要用到 +:if+ 跟 +:unless+ 選項，選項內容可以是符號 (symbol) 、字串 (string) 、或 +Proc+ ???。 +:if+ 選項用來指定驗證何時 *應該* 發生，而 +:unless+ 選項則指定驗證何時 *不應該* 發生。

h4. 在 +:if+ 和 +:unless+ 中使用符號/代號 (Symbol)

條件式驗證時，常常要在驗證前，先呼叫某個方法，來判斷驗證條件是否成立。這個方法的名稱，可以當作符號 (symbol) ，來 associate the +:if+ 跟 +:unless+ 選項。這是最常見的一種用法。

<ruby>
class Order < ActiveRecord::Base
  validates_presence_of :card_number, :if => :paid_with_card?

  def paid_with_card?
    payment_type == "card"
  end
end
</ruby>

h4. 在 +:if+ 和 +:unless+ 中使用字串 (String)

把一段有效的 Ruby 程式碼，以字串的形式，放在條件式中，如此，它就會被丟去給 +eval+ 求值。這個方法，只有適合在字串條件式很短的時候使用。

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :surname, :if => "name.nil?"
end
</ruby>

h4. 在 +:if+ 和 +:unless+ 中使用 Proc ???

最後一種條件式驗證，是呼叫 +Proc+ 物件來 associate +:if+ 和 +:unless+ 。使用 +Proc+ 物件，就可以直接撰寫條件式 (inline condition) ，而不需要另外寫一個方法 (separate method) 。這種作法對 one-liners 來說，再適合不過了。

<ruby>
class Account < ActiveRecord::Base
  validates_confirmation_of :password,
    :unless => Proc.new { |a| a.password.blank? }
end
</ruby>

h3. 撰寫自訂的驗證方法 (Creating Custom Validation Methods)

內建的驗證輔助工具不夠用的時候，您可以自己撰寫驗證方法。

撰寫驗證方法很簡單：撰寫新的方法，在方法中確認模型 (models) 的狀態 (state) ，當模型無效 (invalid) 時，在 +errors+ 集合中加入錯誤訊息。然後，用 +validate+ 、 +validate_on_create+ 或 +validate_on_update+ 等類別方法 (class methods) ，將自訂方法的名稱，以符號/代號 (symbols) 的形式傳入，如此，便能註冊 (register) 您自訂的驗證方法了。

每個類別方法 (class method) 中，都可以傳入多個符號/代號 (symbol) ，與代號相對應的驗證方法，就會按照這個註冊順序，逐一的執行。

<ruby>
class Invoice < ActiveRecord::Base
  validate :expiration_date_cannot_be_in_the_past,
    :discount_cannot_be_greater_than_total_value

  def expiration_date_cannot_be_in_the_past
    errors.add(:expiration_date, "can't be in the past") if
      !expiration_date.blank? and expiration_date < Date.today
  end

  def discount_cannot_be_greater_than_total_value
    errors.add(:discount, "can't be greater than total value") if
      discount > total_value
  end
end
</ruby>

您還可以更進一步，撰寫自訂的驗證輔助工具，然後在幾個不同的模型之間重複使用。例如，某個管理問卷調查的應用程式，需要表達出一個欄位 (field) 對應到一整組選項的狀況：

<ruby>
ActiveRecord::Base.class_eval do
  def self.validates_as_choice(attr_name, n, options={})
    validates_inclusion_of attr_name, {:in => 1..n}.merge(options)
  end
end
</ruby>

像這樣，打開 +ActiveRecord::Base+ ，在裡面定義一個類別方法就可以了。通常這段程式碼，會放在 +config/initializers+ 裡面。這個驗證輔助工具，使用的方式就像這樣：

<ruby>
class Movie < ActiveRecord::Base
  validates_as_choice :rating, 5
end
</ruby>

h3. 處理驗證錯誤 (Working with Validation Errors)

除了前面提的 +valid?+ 和 +invalid?+ 方法之外， Rails 還提供許多其他方法來處理 +errors+ 集合，或者查詢物件的有效性。

下面只列出最常用的方法，全部的方法清單，請參考 +ActiveRecord::Errors+ 的文件。

h4(#working_with_validation_errors-errors). +errors+ 列出物件的錯誤訊息

把該物件的所有錯誤訊息，回傳為一個有序雜湊 (OrderedHash) 。雜湊的 key 是屬性的名稱 (attribute name) ，值 (value) 則是由字串所組成的陣列，裡面是該屬性的所有錯誤訊息。

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name
  validates_length_of :name, :minimum => 3
end

person = Person.new
person.valid? # => false
person.errors
 # => {:name => ["can't be blank", "is too short (minimum is 3 characters)"]}

person = Person.new(:name => "John Doe")
person.valid? # => true
person.errors # => []
</ruby>

h4(#working_with_validation_errors-errors-2). +errors[]+ 列出屬性的錯誤訊息

+errors[]+ 的用途是查看某特定屬性的錯誤訊息。它傳回字串陣列，每個字串就是一筆錯誤訊息。如果此屬性沒有任何錯誤，則傳回空的陣列。

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name
  validates_length_of :name, :minimum => 3
end

person = Person.new(:name => "John Doe")
person.valid? # => true
person.errors[:name] # => []

person = Person.new(:name => "JD")
person.valid? # => false
person.errors[:name] # => ["is too short (minimum is 3 characters)"]

person = Person.new
person.valid? # => false
person.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]
</ruby>

h4. +errors.add+ 手動加入錯誤訊息

+add+ 方法可以在某個屬性底下，手動加入錯誤訊息。這些錯誤訊息，在使用者眼中大概會看到的樣子，可以用 +errors.full_messages+ 或 +errors.to_a+ 這兩種方法來預覽，它們會把屬性的名稱開頭變大寫後，顯示在錯誤訊息前面。 +add+ 方法接收兩樣東西：屬性名稱，和您想手動附上的錯誤訊息。

<ruby>
class Person < ActiveRecord::Base
  def a_method_used_for_validation_purposes
    errors.add(:name, "cannot contain the characters !@#%*()_-+=")
  end
end

person = Person.create(:name => "!@#")

person.errors[:name]
 # => ["cannot contain the characters !@#%*()_-+="]

person.errors.full_messages
 # => ["Name cannot contain the characters !@#%*()_-+="]
</ruby>

除了 +add+ 之外的另一個作法，是用 +[]=+ 這個 ??? 設定式 (setter)

<ruby>
  class Person < ActiveRecord::Base
    def a_method_used_for_validation_purposes
      errors[:name] = "cannot contain the characters !@#%*()_-+="
    end
  end

  person = Person.create(:name => "!@#")

  person.errors[:name]
   # => ["cannot contain the characters !@#%*()_-+="]

  person.errors.to_a
   # => ["Name cannot contain the characters !@#%*()_-+="]
</ruby>

h4. +errors[:base]+ 關聯到物件整體的錯誤訊息

通常錯誤訊息是關連到屬性，不過，您也可以加入跟整個物件相關連的錯誤訊息。有時候，不需要管各個屬性的值是什麼，只要表示出這個物件沒有通過驗證就好，此時，就可以用 +errors[:base]+ ，它是一個陣列，只要在陣列中加入字串，這字串就可以拿來當物件的錯誤訊息了。

<ruby>
class Person < ActiveRecord::Base
  def a_method_used_for_validation_purposes
    errors[:base] << "This person is invalid because ..."
  end
end
</ruby>

h4. +errors.clear+ 清空錯誤訊息

+clear+ 方法用來清空 +errors+ 集合裡的所有錯誤訊息。這個動作，不會讓無效物件變成有效，因為雖然錯誤訊息清空了，但下次呼叫 +valid?+ 方法時，或者想把物件寫入資料庫時，都會再一次的觸發驗證，一旦驗證失敗， +errors+ 集合就會再度填滿。

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name
  validates_length_of :name, :minimum => 3
end

person = Person.new
person.valid? # => false
person.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]

person.errors.clear
person.errors.empty? # => true

p.save # => false

p.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]
</ruby>

h4. +errors.size+ 物件的錯誤訊息總數

+size+ 方法會傳回這個物件的所有錯誤訊息的總數。

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name
  validates_length_of   :name, :minimum => 3
  validates_presence_of :email
end

person = Person.new
person.valid? # => false
person.errors.size # => 3

person = Person.new(:name => "Andrea", :email => "andrea@example.com")
person.valid? # => true
person.errors.size # => 0
</ruby>

h3. 在視圖中秀出驗證錯誤 (Displaying Validation Errors in the View)

Rails 內建了輔助工具 (helpers) ，可以在視圖模板 (view templates) 中，顯示模型 (models) 的錯誤訊息 (error messages) 。

h4. +error_messages+ 以及 +error_messages_for+ 在視圖中呈現錯誤訊息

用 +form_for+ 輔助工具新增表格的時候，可以在 ??? 表格產生器 (form builder) 裡面用 +error_messages+ 方法，把目前的模型實體 (model instance) 的全部驗證訊息，演算呈現 (render) 出來。

<ruby>
class Product < ActiveRecord::Base
  validates_presence_of :description, :value
  validates_numericality_of :value, :allow_nil => true
end
</ruby>

<erb>
<%= form_for(@product) do |f| %>
  <%= f.error_messages %>
  <p>
    <%= f.label :description %><br />
    <%= f.text_field :description %>
  </p>
  <p>
    <%= f.label :value %><br />
    <%= f.text_field :value %>
  </p>
  <p>
    <%= f.submit "Create" %>
  </p>
<% end %>
</erb>

送出 (submit) 上述的表單時，如果表單內有空白欄位 (empty fields) ，就會得到如下圖般的回應。是說，預設狀況下是沒有套用樣式 (styles) 的就是了。

!images/error_messages.png(Error messages)!

對於指定給視圖模板 (view template) 的模型 (model) ，要顯示它的錯誤訊息的話，也可以用 +error_messages_for+ 輔助工具來做。它跟上面的範例很像，最後結果也是一模一樣：

<erb>
<%= error_messages_for :product %>
</erb>

呈現錯誤訊息的文字，格式是「大寫開頭的屬性名稱 + 錯誤訊息」。

+form.error_messages+ 跟 +error_messages_for+ 這兩個輔助工具，都可以針對包裹著訊息文字的 +div+ 元素 (element) ，接收一些自訂的選項，用來自訂標題文字 (header text) 、標題文字下方的訊息、以及標題的元素標籤 (tag) 。

<erb>
<%= f.error_messages :header_message => "Invalid product!",
  :message => "You'll need to fix the following fields:",
  :header_tag => :h3 %>
</erb>

會產生以下內容：

!images/customized_error_messages.png(Customized error messages)!

如果對任一個選項傳入 +nil+ 值，它會 ??? get rid of the respective section of the +div+.

h4. 自訂錯誤訊息的串接樣式表 (CSS)

用來自訂錯誤訊息樣式的選擇器 (selectors) 包括：

* +.field_with_errors+ - Style for the form fields and labels with errors.
* +#errorExplanation+ - Style for the +div+ element with the error messages.
* +#errorExplanation h2+ - Style for the header of the +div+ element.
* +#errorExplanation p+ - Style for the paragraph that holds the message that appears right below the header of the +div+ element.
* +#errorExplanation ul li+ - Style for the list items with individual error messages.

Scaffolding for example generates +public/stylesheets/scaffold.css+, which defines the red-based style you saw above.

The name of the class and the id can be changed with the +:class+ and +:id+ options, accepted by both helpers.

h4. Customizing the Error Messages HTML

By default, form fields with errors are displayed enclosed by a +div+ element with the +field_with_errors+ CSS class. However, it's possible to override that.

The way form fields with errors are treated is defined by +ActionView::Base.field_error_proc+. This is a +Proc+ that receives two parameters:

* A string with the HTML tag
* An instance of +ActionView::Helpers::InstanceTag+.

Here is a simple example where we change the Rails behaviour to always display the error messages in front of each of the form fields with errors. The error messages will be enclosed by a +span+ element with a +validation-error+ CSS class. There will be no +div+ element enclosing the +input+ element, so we get rid of that red border around the text field. You can use the +validation-error+ CSS class to style it anyway you want.

<ruby>
ActionView::Base.field_error_proc = Proc.new do |html_tag, instance|
  if instance.error_message.kind_of?(Array)
    %(#{html_tag}<span class="validation-error">&nbsp;
      #{instance.error_message.join(',')}</span>)
  else
    %(#{html_tag}<span class="validation-error">&nbsp;
      #{instance.error_message}</span>)
  end
end
</ruby>

This will result in something like the following:

!images/validation_error_messages.png(Validation error messages)!

h3. Callbacks Overview

Callbacks are methods that get called at certain moments of an object's life cycle. With callbacks it's possible to write code that will run whenever an Active Record object is created, saved, updated, deleted, validated, or loaded from the database.

h4. Callback Registration

In order to use the available callbacks, you need to register them. You can do that by implementing them as ordinary methods, and then using a macro-style class method to register them as callbacks.

<ruby>
class User < ActiveRecord::Base
  validates_presence_of :login, :email

  before_validation :ensure_login_has_a_value

  protected
  def ensure_login_has_a_value
    if login.nil?
      self.login = email unless email.blank?
    end
  end
end
</ruby>

The macro-style class methods can also receive a block. Consider using this style if the code inside your block is so short that it fits in just one line.

<ruby>
class User < ActiveRecord::Base
  validates_presence_of :login, :email

  before_create {|user| user.name = user.login.capitalize
	if user.name.blank?}
end
</ruby>

It's considered good practice to declare callback methods as being protected or private. If left public, they can be called from outside of the model and violate the principle of object encapsulation.

h3. Available Callbacks

Here is a list with all the available Active Record callbacks, listed in the same order in which they will get called during the respective operations:

h4. Creating an Object

* +before_validation+
* +after_validation+
* +before_save+
* +after_save+
* +before_create+
* +around_create+
* +after_create+

h4. Updating an Object

* +before_validation+
* +after_validation+
* +before_save+
* +after_save+
* +before_update+
* +around_update+
* +after_update+

h4. Destroying an Object

* +before_destroy+
* +after_destroy+
* +around_destroy+

WARNING. +after_save+ runs both on create and update, but always _after_ the more specific callbacks +after_create+ and +after_update+, no matter the order in which the macro calls were executed.

h4. +after_initialize+ and +after_find+

The +after_initialize+ callback will be called whenever an Active Record object is instantiated, either by directly using +new+ or when a record is loaded from the database. It can be useful to avoid the need to directly override your Active Record +initialize+ method.

The +after_find+ callback will be called whenever Active Record loads a record from the database. +after_find+ is called before +after_initialize+ if both are defined.

The +after_initialize+ and +after_find+ callbacks are a bit different from the others. They have no +before_*+ counterparts, and the only way to register them is by defining them as regular methods. If you try to register +after_initialize+ or +after_find+ using macro-style class methods, they will just be ignored. This behaviour is due to performance reasons, since +after_initialize+ and +after_find+ will both be called for each record found in the database, significantly slowing down the queries.

<ruby>
class User < ActiveRecord::Base
  def after_initialize
    puts "You have initialized an object!"
  end

  def after_find
    puts "You have found an object!"
  end
end

>> User.new
You have initialized an object!
=> #<User id: nil>

>> User.first
You have found an object!
You have initialized an object!
=> #<User id: 1>
</ruby>

h3. Running Callbacks

The following methods trigger callbacks:


* +create+
* +create!+
* +decrement!+
* +destroy+
* +destroy_all+
* +increment!+
* +save+
* +save!+
* +save(false)+
* +toggle!+
* +update+
* +update_attribute+
* +update_attributes+
* +update_attributes!+
* +valid?+

Additionally, the +after_find+ callback is triggered by the following finder methods:

* +all+
* +first+
* +find+
* +find_all_by_<em>attribute</em>+
* +find_by_<em>attribute</em>+
* +find_by_<em>attribute</em>!+
* +last+

The +after_initialize+ callback is triggered every time a new object of the class is initialized.

h3. Skipping Callbacks

Just as with validations, it's also possible to skip callbacks. These methods should be used with caution, however, because important business rules and application logic may be kept in callbacks. Bypassing them without understanding the potential implications may lead to invalid data.

* +decrement+
* +decrement_counter+
* +delete+
* +delete_all+
* +find_by_sql+
* +increment+
* +increment_counter+
* +toggle+
* +update_all+
* +update_counters+

h3. Halting Execution

As you start registering new callbacks for your models, they will be queued for execution. This queue will include all your model's validations, the registered callbacks, and the database operation to be executed.

The whole callback chain is wrapped in a transaction. If any <em>before</em> callback method returns exactly +false+ or raises an exception the execution chain gets halted and a ROLLBACK is issued; <em>after</em> callbacks can only accomplish that by raising an exception.

WARNING. Raising an arbitrary exception may break code that expects +save+ and friends not to fail like that. The +ActiveRecord::Rollback+ exception is thought precisely to tell Active Record a rollback is going on. That one is internally captured but not reraised.

h3. Relational Callbacks

Callbacks work through model relationships, and can even be defined by them. Let's take an example where a user has many posts. In our example, a user's posts should be destroyed if the user is destroyed. So, we'll add an +after_destroy+ callback to the +User+ model by way of its relationship to the +Post+ model.

<ruby>
class User < ActiveRecord::Base
  has_many :posts, :dependent => :destroy
end

class Post < ActiveRecord::Base
  after_destroy :log_destroy_action

  def log_destroy_action
    puts 'Post destroyed'
  end
end

>> user = User.first
=> #<User id: 1>
>> user.posts.create!
=> #<Post id: 1, user_id: 1>
>> user.destroy
Post destroyed
=> #<User id: 1>
</ruby>

h3. Conditional Callbacks

Like in validations, we can also make our callbacks conditional, calling them only when a given predicate is satisfied. You can do that by using the +:if+ and +:unless+ options, which can take a symbol, a string or a +Proc+. You may use the +:if+ option when you want to specify when the callback *should* get called. If you want to specify when the callback *should not* be called, then you may use the +:unless+ option.

h4. Using +:if+ and +:unless+ with a Symbol

You can associate the +:if+ and +:unless+ options with a symbol corresponding to the name of a method that will get called right before the callback. When using the +:if+ option, the callback won't be executed if the method returns false; when using the +:unless+ option, the callback won't be executed if the method returns true. This is the most common option. Using this form of registration it's also possible to register several different methods that should be called to check if the callback should be executed.

<ruby>
class Order < ActiveRecord::Base
  before_save :normalize_card_number, :if => :paid_with_card?
end
</ruby>

h4. Using +:if+ and +:unless+ with a String

You can also use a string that will be evaluated using +eval+ and needs to contain valid Ruby code. You should use this option only when the string represents a really short condition.

<ruby>
class Order < ActiveRecord::Base
  before_save :normalize_card_number, :if => "paid_with_card?"
end
</ruby>

h4. Using +:if+ and +:unless+ with a Proc

Finally, it's possible to associate +:if+ and +:unless+ with a +Proc+ object. This option is best suited when writing short validation methods, usually one-liners.

<ruby>
class Order < ActiveRecord::Base
  before_save :normalize_card_number,
    :if => Proc.new { |order| order.paid_with_card? }
end
</ruby>

h4. Multiple Conditions for Callbacks

When writing conditional callbacks, it's possible to mix both +:if+ and +:unless+ in the same callback declaration.

<ruby>
class Comment < ActiveRecord::Base
  after_create :send_email_to_author, :if => :author_wants_emails?,
    :unless => Proc.new { |comment| comment.post.ignore_comments? }
end
</ruby>

h3. Callback Classes

Sometimes the callback methods that you'll write will be useful enough to be reused by other models. Active Record makes it possible to create classes that encapsulate the callback methods, so it becomes very easy to reuse them.

Here's an example where we create a class with an +after_destroy+ callback for a +PictureFile+ model.

<ruby>
class PictureFileCallbacks
  def after_destroy(picture_file)
    File.delete(picture_file.filepath)
      if File.exists?(picture_file.filepath)
  end
end
</ruby>

When declared inside a class the callback method will receive the model object as a parameter. We can now use it this way:

<ruby>
class PictureFile < ActiveRecord::Base
  after_destroy PictureFileCallbacks.new
end
</ruby>

Note that we needed to instantiate a new +PictureFileCallbacks+ object, since we declared our callback as an instance method. Sometimes it will make more sense to have it as a class method.

<ruby>
class PictureFileCallbacks
  def self.after_destroy(picture_file)
    File.delete(picture_file.filepath)
      if File.exists?(picture_file.filepath)
  end
end
</ruby>

If the callback method is declared this way, it won't be necessary to instantiate a +PictureFileCallbacks+ object.

<ruby>
class PictureFile < ActiveRecord::Base
  after_destroy PictureFileCallbacks
end
</ruby>

You can declare as many callbacks as you want inside your callback classes.

h3. Observers

Observers are similar to callbacks, but with important differences. Whereas callbacks can pollute a model with code that isn't directly related to its purpose, observers allow you to add the same functionality outside of a model. For example, it could be argued that a +User+ model should not include code to send registration confirmation emails. Whenever you use callbacks with code that isn't directly related to your model, you may want to consider creating an observer instead.

h4. Creating Observers

For example, imagine a +User+ model where we want to send an email every time a new user is created. Because sending emails is not directly related to our model's purpose, we could create an observer to contain this functionality.

<shell>
rails generate observer User
</shell>

<ruby>
class UserObserver < ActiveRecord::Observer
  def after_create(model)
    # code to send confirmation email...
  end
end
</ruby>

As with callback classes, the observer's methods receive the observed model as a parameter.

h4. Registering Observers

Observers are conventionally placed inside of your +app/models+ directory and registered in your application's +config/environment.rb+ file. For example, the +UserObserver+ above would be saved as +app/models/user_observer.rb+ and registered in +config/environment.rb+ this way:

<ruby>
# Activate observers that should always be running
config.active_record.observers = :user_observer
</ruby>

As usual, settings in +config/environments+ take precedence over those in +config/environment.rb+. So, if you prefer that an observer doesn't run in all environments, you can simply register it in a specific environment instead.

h4. Sharing Observers

By default, Rails will simply strip "Observer" from an observer's name to find the model it should observe. However, observers can also be used to add behaviour to more than one model, and so it's possible to manually specify the models that our observer should observe.

<ruby>
class MailerObserver < ActiveRecord::Observer
  observe :registration, :user

  def after_create(model)
    # code to send confirmation email...
  end
end
</ruby>

In this example, the +after_create+ method would be called whenever a +Registration+ or +User+ was created. Note that this new +MailerObserver+ would also need to be registered in +config/environment.rb+ in order to take effect.

<ruby>
# Activate observers that should always be running
config.active_record.observers = :mailer_observer
</ruby>

h3. Changelog

"Lighthouse ticket":http://rails.lighthouseapp.com/projects/16213/tickets/26-active-record-validations-and-callbacks

* July 20, 2010: Fixed typos and rephrased some paragraphs for clarity. "Jaime Iniesta":http://jaimeiniesta.com
* May 24, 2010: Fixed document to validate XHTML 1.0 Strict. "Jaime Iniesta":http://jaimeiniesta.com
* May 15, 2010: Validation Errors section updated by "Emili Parreño":http://www.eparreno.com
* March 7, 2009: Callbacks revision by Trevor Turk
* February 10, 2009: Observers revision by Trevor Turk
* February 5, 2009: Initial revision by Trevor Turk
* January 9, 2009: Initial version by "Cássio Marques":credits.html#cmarques
