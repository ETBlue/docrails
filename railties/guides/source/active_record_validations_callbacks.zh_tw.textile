h2. Active Record 的驗證 (Validations) 與回呼 (Callbacks)

這一章說明如何 hook into Active Record 物件的生命週期：在物件進入資料庫之前，驗證它的狀態，以及，在物件生命週期的特定時間點，執行自訂的操作。

讀完本篇，您會：

* 了解 Active Record 物件的生命週期 (life cycle)
* 使用內建的 Active Record 驗證輔助工具 (validation helpers)
* 打造您自訂的驗證方法
* 處理驗證過程中所產生的錯誤訊息
* 在物件生命週期期間，會發生一些事件，您將學會針對這些事件，撰寫回呼方法 (callback methods) 。
* 在回呼 (callbacks) 之間，有些共通的行為，您將學會針對這些行為，撰寫特殊類別 (special classes) ，以封裝 (encapsulate) 它們。 
* 有些事件 (events) ，並沒有定義在原來的類別中，您將學會針對這些事件，建立觀測器 (observers)，以便回應它們。
endprologue.

h3. 物件生命週期 (Object Life Cycle)

Rails 正常操作下，會產生一些物件，也會更新、銷毀它們。為此，Active Record 提供了 <em>object life cycle</em> 內的 hooks，讓您可以操控程式、操控資料。其中，驗證 (validations) 是用來確保只有有效的資料，被存到資料庫裡面。而回呼 (callbacks) 和觀測器 (observers) ，則是在物件狀態變化之前、或變化之後，觸發相關的邏輯。

h3. 驗證的概觀 (Validations Overview)

深入 Rails 的驗證 (validations) 細節前，先了解一下驗證扮演的角色。

h4. 為什麼要驗證 (Validations) ？

驗證 (validations) 的用意，是要確保資料庫裡，只有有效資料 (valid data) 才存進去。比方說，您的應用程式，可能要確定每個使用者，都提供有效的電子郵件地址、和郵寄地址等。

在資料存進資料庫前，有幾個驗證的方法，包括：原生的資料庫約束 (native database constraints) 、客戶端驗證 (client-side validations) 、控制器層級的驗證 (controller-level validations) 、以及模型層級的驗證 (model-level validations)。

* 資料庫約束 (database constraints) 或者是預存程序 (stored procedures) ，這些驗證機制，要依賴特定的資料庫，所以，測試和維護會比較難。不過，如果資料庫會去給別的應用程式用，那麼，在資料庫層做約束可能就是不錯的作法。另外，資料庫層級的驗證可以很安全的處理一些事情，像是，在重度使用的資料表中，確保唯一值 (uniqueness) 之類的。這些事情，如果用其他的方法，會比較難實作。
* 客戶端的驗證 (client-side validations) 雖然可以用，但單單用這個的話，通常不太可靠。如果用 JavaScript 來做，要是使用者的瀏覽器把 JavaScript 關掉，那驗證就被略過了。不過，畢竟客戶端驗證，可以給使用者很即時的回饋，所以，要是能跟其他驗證手法併用，那倒是挺方便的。
* 控制器層級的驗證 (controller-level validations) ，也是可以用，但常常很笨重，不好測試跟維護。不管怎樣，"keep your controllers skinny":http://weblog.jamisbuck.org/2006/10/18/skinny-controller-fat-model 總是好的，長遠的說，可以讓程式用起來很愉快。
* 模型層級的驗證 (model-level validations) ，是最佳作法。這種驗證方式，不用去管資料庫是哪個系統，也不會被使用者略過，測試起來很方便，也容易維護。為了方便大家使用 model 層級的驗證，Rails 針對常用功能，內建了輔助工具，當然，您也可以撰寫自己的驗證方法。

h4. 什麼時候會發生驗證 (Validation) ？

Active Record 類別底下，有兩種物件：跟某一筆資料對應的，或者沒跟資料對應的。當您使用 +new+ 之類的方法，建立了一個新物件，此時，它還不屬於資料庫。等到您呼叫那個物件的 +save+ 方法，它才會被存入適當的資料表中。至於，物件目前是否已存入資料庫，則是用 Active Record 的實體方法 (instance method) +new_record?+ 來確認。簡單舉例，這裡有個 Active Record 底下的類別 (class) ：

<ruby>
class Person < ActiveRecord::Base
end
</ruby>

從 +rails console+ 的輸出結果，可以看出它的運作方式：

<shell>
>> p = Person.new(:name => "John Doe")
=> #<Person id: nil, name: "John Doe", created_at: nil, :updated_at: nil>
>> p.new_record?
=> true
>> p.save
=> true
>> p.new_record?
=> false
</shell>

一筆新記錄的新增、儲存，會對資料庫送出一個 SQL 的 +INSERT+ 操作 (operation) 。更新現有的記錄，則送出 +UPDATE+ 操作。通常，送命令到資料庫之前，會做驗證。過程中，有任何一個驗證失敗的話，這個物件就會被標記為無效 (marked as invalid) ，於是 Active Record 就不會執行 +INSERT+ 或 +UPDATE+ 的操作，如此一來，無效的物件就不會存進資料庫。您也可以針對物件新增、儲存、更新，自訂專屬的驗證功能。

CAUTION: 在資料庫裡面，要改變物件的狀態 (state) ，有很多種方法。其中，有些會觸發驗證機制，有些則不會。也就是說，不注意的話，是有可能把無效狀態 (invalid state) 的物件，存到資料庫裡去的。

下面列出的方法，會觸發驗證，只有驗證合格的物件才會存入資料庫：

* +create+
* +create!+
* +save+
* +save!+
* +update+
* +update_attributes+
* +update_attributes!+

這些方法中，尾巴附有一個驚嘆號的版本 (bang versions) ，像是 +save!+ ，會在這筆紀錄 invalid 的時候，丟出例外 (raise an exception) 。沒有驚嘆號的 (non-bang versions) 則不會丟出例外，其中， +save+ 跟 +update_attributes+ 會傳回 +false+ ，而 +create+ 跟 +update+ 則單純的傳回物件本身。

h4. 略過驗證 (Skipping Validations)

下面列出的方法，會略過驗證，不管物件是否有效，都會將它存到資料庫中。所以，要小心使用。

* +decrement!+
* +decrement_counter+
* +increment!+
* +increment_counter+
* +toggle!+
* +update_all+
* +update_attribute+
* +update_counters+

對了，如果把 +:validate => false+ 當作引數 (argument) 傳入的話， +save+ 也是可以略過驗證的。這個技巧也是要小心使用。

* +save(:validate => false)+

h4. +valid?+ 與 +invalid?+ （驗證後，是否有錯誤訊息存在）

Rails 在確認物件是否有效的時候，是用 +valid?+ 方法，您平常也可以自己把 +valid?+ 拿來用。它會觸發驗證，如果驗證完，沒有錯誤訊息附加到物件上的話，就傳回真值 (true) ，反之，有錯誤訊息的話，就是假值 (false) 。

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name
end

Person.create(:name => "John Doe").valid? # => true
Person.create(:name => nil).valid? # => false
</ruby>

Active Record 在執行驗證的時候，任何的錯誤訊息，都可以用 +errors+ 這個實體方法 (instance method) 來取得 (accessed) 。驗證結束後，如果這個集合 (collection) 仍然是空的，那在定義上，這個物件就會被認為是有效的 (valid) 。

用 +new+ 實體化 (instantiated) 出來的物件，即使它在技術上是無效的，也不會回報錯誤訊息，因為，執行 +new+ 的時候，並不會進行驗證。

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name
end

>> p = Person.new
=> #<Person id: nil, name: nil>
>> p.errors
=> {}

>> p.valid?
=> false
>> p.errors
=> {:name=>["can't be blank"]}

>> p = Person.create
=> #<Person id: nil, name: nil>
>> p.errors
=> {:name=>["can't be blank"]}

>> p.save
=> false

>> p.save!
=> ActiveRecord::RecordInvalid: Validation failed: Name can't be blank

>> Person.create!
=> ActiveRecord::RecordInvalid: Validation failed: Name can't be blank
</ruby>

+invalid?+ 純粹是 +valid?+ 的相反， +invalid?+ 會觸發驗證，如果有任何錯誤訊息加到物件上，就傳回真值 (true) ， 反之則是假值 (false) 。

h4(#validations_overview-errors). +errors[]+ （某個屬性內，錯誤訊息的陣列集合）

對於物件的某個屬性 (attribute) ，要確認是否有效 (valid) 的話，可以用 +errors[:attribute]+ ，它會傳回一個陣列 (array) ，裡面有這個屬性的全部的錯誤訊息 (attribute errors) 。如果，這個屬性沒有任何錯誤訊息，那就會傳回空的陣列。

這個方法，要在驗證執行過 _之後_ 才能使用，因為，它只會檢查錯誤訊息的集合 (errors collection) ，而不會去觸發驗證本身。這跟上面提過的 +ActiveRecord::Base#invalid?+ 方法，是不一樣的，因為它不會去確認物件的有效性 (validity) as a whole，它只是去看這個物件的個別屬性，有沒有錯誤訊息在裡面而已。

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name
end

>> Person.new.errors[:name].any? # => false
>> Person.create.errors[:name].any? # => true
</ruby>

關於驗證的錯誤訊息 (validation errors) ，之後的 "Working with Validation Errors":#working-with-validation-errors 章節會再深入解釋。現在，讓我們回頭看看 Rails 內建的驗證輔助工具 (validation helpers) 。

h3. 驗證輔助工具 (Validation Helpers)

Active Record 預先定義好許多驗證輔助工具，您可以在類別定義 (class definition) 裡面，直接使用它們。這些輔助工具，有共通的驗證規則，每次，一個驗證失敗時，就會在該物件的 +errors+ 集合中，加入一條錯誤訊息，這個訊息，則會跟當時正在驗證的欄位 (field) 相關連。

每個輔助工具，可以接收 (accepts) 多個屬性名稱 (attribute names) ，要幾個都可以。所以，只要用一行程式碼，就可以把同一種驗證方式，套用到好幾個不同的屬性上面。

輔助工具都可接收 +:on+ 跟 +:message+ 選項 (options) ，這些選項，會定義驗證該何時執行，以及，如果驗證失敗的話，該加什麼訊息到 +errors+ 集合中, respectively 。選項 +:on+ 的作用，是將一個值 +:save+ （預設），或者 +:create+ ，或者 +:update+ 。至於選項 +:message+ 的作用，則是自訂錯誤訊息，如果，沒有自訂 +:message+ ，就會採用預設的，反正，每個驗證輔助工具，都有預設的訊息可以用。底下讓我們一個一個來看。

h4. +validates_acceptance_of+ （確定使用者已經接受）

當使用者送出表格 (form submitted) 時，針對使用者介面中的核取方塊 (checkbox) ，驗證它有沒有勾選。會用到的地方，通常是應用程式的服務條款 (terms of service) ，要使用者確認「我同意」、「我已閱讀」之類的。這種驗證，幾乎都是網路應用程式 (web applications) 在用。這個 'acceptance （是否已接受）' 不用記在資料庫裡，所以，沒有對應的欄位 (field) 也沒關係，輔助工具會建立一個虛擬的屬性 (virtual attribute) 來應付。

<ruby>
class Person < ActiveRecord::Base
  validates_acceptance_of :terms_of_service
end
</ruby>

+validates_acceptance_of+ 預設的錯誤訊息是 "_must be accepted_" 。

+validates_acceptance_of+ 可以接收 +:accept+ 選項，決定什麼值代表 acceptance （已接受），預設的值是 "1" ，您要改掉它也可以。

<ruby>
class Person < ActiveRecord::Base
  validates_acceptance_of :terms_of_service, :accept => 'yes'
end
</ruby>

h4. +validates_associated+ （驗證其他有關連的模型）

如果您的 model ，跟其他 models 有關連 (associations) ，而這些相關的 models 也需要驗證，那麼，就需要使用這個輔助工具了。使用 +validates_associated+ 後，當您儲存物件時，每一個跟它相關的物件，都會呼叫 +valid?+ 方法。

<ruby>
class Library < ActiveRecord::Base
  has_many :books
  validates_associated :books
end
</ruby>

所有的資料庫關聯類型 (association types) ，都可以使用這種驗證。

CAUTION: 不要在一個資料庫關聯的兩端，同時使用 +validates_associated+ ，因為，它們會一直互相呼叫，最後沒完沒了，停不下來。

+validates_associated+ 預設的錯誤訊息是 "_is invalid_" 。每個相關連的物件 (associated object) 都有自己的 +errors+ 集合，自己的錯誤訊息，只會出現在自己的集合裡面，不會跑到對方的模型 (calling model) 裡面。

h4. +validates_confirmation_of+ （檢查使用者的再次確認）

如果有兩個文字欄位 (text fields) ，必須收到一模一樣的內容，就會用到這個驗證，比方說，要使用者再確認一次 email address 或是 password 的時候。這個驗證功能，會建立一個虛擬屬性 (virtual attribute) ，虛擬屬性的名稱，就是把那個需要確認的欄位的名稱，尾巴後面再加上 "_confirmation" 。

<ruby>
class Person < ActiveRecord::Base
  validates_confirmation_of :email
end
</ruby>

使用這個驗證的時候，在視圖模板 (view template) 中，可以寫成：

<erb>
<%= text_field :person, :email %>
<%= text_field :person, :email_confirmation %>
</erb>

上面的檢查，只有在 +email_confirmation+ 不是空值 +nil+ 的時候，才會執行，所以，要 require confirmation 的話，要事先確認驗證屬性 (confirmation attribute) 是不是存在 (presence check) 。關於這點，後面會在 +validates_presence_of+ 講到。

<ruby>
class Person < ActiveRecord::Base
  validates_confirmation_of :email
  validates_presence_of :email_confirmation
end
</ruby>

+validates_confirmation_of+ 預設的錯誤訊息是 "_doesn't match confirmation_" 。

h4. +validates_exclusion_of+ （確定屬性的值不在其內）

確認該屬性的值，沒有在指定的 set 中出現。這個 set ，可以是任何一個 enumerable 物件。

<ruby>
class Account < ActiveRecord::Base
  validates_exclusion_of :subdomain, :in => %w(www),
    :message => "Subdomain %{value} is reserved."
end
</ruby>

+validates_exclusion_of+ 有個 +:in+ 的選項，會接收一組值，這組值，也就是被驗證的屬性，所不該接受的值。+:in+ 選項有個別名 (alias) 叫做 +:within+ ，功能是一樣的。上面的範例用 +:message+ 選項??? 來表現如何 include 屬性的值 ???。

+validates_exclusion_of+ 預設的錯誤訊息是 "_is reserved_" 。

h4. +validates_format_of+ （檢查屬性值的格式）

這個工具，會測試屬性的值，是否符合 +:with+ 選項所指定的常規表示式 (regular expression) 。

<ruby>
class Product < ActiveRecord::Base
  validates_format_of :legacy_code, :with => /\A[a-zA-Z]+\z/,
    :message => "Only letters allowed"
end
</ruby>

+validates_format_of+ 預設的錯誤訊息是 "_is invalid_" 。

h4. +validates_inclusion_of+ （確定屬性的值有被包括在內）

確認該屬性的值，有被包括在指定的 set 裡面，這個 set 可以是任何 enumerable 物件。

<ruby>
class Coffee < ActiveRecord::Base
  validates_inclusion_of :size, :in => %w(small medium large),
    :message => "%{value} is not a valid size"
end
</ruby>

+validates_inclusion_of+ 有個 +:in+ 選項，會接收一組值，就是被驗證的屬性，所能夠接受的值。 +:in+ 選項有個別名 (alias) 叫做 +:within+ ，功能是相同的。上面的範例用 +:message+ 選項來表現如何 include 屬性的值。

+validates_inclusion_of+ 預設的錯誤訊息是 "_is not included in the list_" 。

h4. +validates_length_of+ （確定長度在指定範圍內）

驗證屬性值的長度。這個工具有多種選項 (options) ，所以，您有許多方法，可以指定長度限制 (length constraints) ：

<ruby>
class Person < ActiveRecord::Base
  validates_length_of :name, :minimum => 2
  validates_length_of :bio, :maximum => 500
  validates_length_of :password, :in => 6..20
  validates_length_of :registration_number, :is => 6
end
</ruby>

可用的選項，包括：

* +:minimum+ - 屬性的值不能比指定長度短。
* +:maximum+ - 屬性的值不能比指定長度長。
* +:in+ (or +:within+) - 屬性的值的長度，要在某個區間 (interval) 之內。所以，這個選項的值，必須是一個範圍 (range) 。
* +:is+ - 屬性的值的長度，要跟指定的長度相等。

不同類型的長度驗證，預設的錯誤訊息，也各自不同。要自訂錯誤訊息，可以用 +:wrong_length+ 、 +:too_long+ 、+:too_short+ 選項，搭配 <tt>%{count}</tt> 做為 placeholder ，留給跟長度限制有關的數字。同樣的，您可以用 +:message+ 選項來自訂錯誤訊息。

<ruby>
class Person < ActiveRecord::Base
  validates_length_of :bio, :maximum => 1000,
    :too_long => "%{count} characters is the maximum allowed"
end
</ruby>

預設狀態下，此工具會計算字元 (characters) ，不過，要用別的方式 split the value 的話，您可以用 +:tokenizer+ 選項：

<ruby>
class Essay < ActiveRecord::Base
  validates_length_of :content,
    :minimum   => 300,
    :maximum   => 400,
    :tokenizer => lambda { |str| str.scan(/\w+/) },
    :too_short => "must have at least %{count} words",
    :too_long  => "must have at most %{count} words"
end
</ruby>

+validates_length_of+ 輔助工具，別名叫做 +validates_size_of+ 。

h4. +validates_numericality_of+ （確保屬性的值只包括數值）

驗證您的屬性只包含數字值 (numeric values) 。預設是符合 match an optional sign 後面接 followed by 一個整數 (integral) 或浮點數 (floating point number) 。如果只想允許整數，把 +:only_integer+ 設定為 true 就可以了。

如果 +:only_integer+ 設為 +true+ ，會用這個常規表示式

<ruby>
/\A[+-]?\d+\Z/
</ruby>

來驗證屬性的值。反之，如果沒設定，則會嘗試用 +Float+ 來把值轉換成數字。

WARNING. 上面的常規表示式，允許 ??? 字元 (trailing newline character) 。

<ruby>
class Player < ActiveRecord::Base
  validates_numericality_of :points
  validates_numericality_of :games_played, :only_integer => true
end
</ruby>

除了 +:only_integer+ 之外， +validates_numericality_of+ 還接受下列這些選項，來限制允許的值 (acceptable values) ：

* +:greater_than+ - 必須比這個值還大。預設的錯誤訊息是 "_must be greater than %{count}_" 。
* +:greater_than_or_equal_to+ - 必須大於或等於這個值。預設的錯誤訊息是 "_must be greater than or equal to %{count}_" 。
* +:equal_to+ - 必須等於這個值。預設的錯誤訊息是 "_must be equal to %{count}_" 。
* +:less_than+ - 必須小於這值。預設的錯誤訊息是 "_must be less than %{count}_" 。
* +:less_than_or_equal_to+ - 必須小於或等於這個值。預設的錯誤訊息是 "_must be less than or equal to %{count}_" 。
* +:odd+ - 如果設定為 true ，則被驗證的值必須是奇數???。預設的錯誤訊息是 "_must be odd_" 。
* +:even+ - 如果設定為 true ，則被驗證的值必須是偶數???。預設的錯誤訊息是 "_must be even_" 。

+validates_numericality_of+ 預設的錯誤訊息是 "_is not a number_" 。

h4. +validates_presence_of+ （確定某個屬性有存在）

驗證指定的屬性不是空的。此工具使用 +blank?+ 方法，去檢查屬性值是否為 +nil+ 或者空字串 (blank string) ，所謂空字串指的是沒有內容 (empty) 、或者由空白 (whitespace) 組成的字串。

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name, :login, :email
end
</ruby>

如果，要確認資料庫關聯 (association) 的存在，那要測試的，是存不存在 map the association 的外部鍵 (foreign key) ，而不是相關連的物件 (associated object) 本身。

<ruby>
class LineItem < ActiveRecord::Base
  belongs_to :order
  validates_presence_of :order_id
end
</ruby>

??? 由於 +false.blank?+ 是 true ，Since +false.blank?+ is true, ??? 要驗證布林欄位 (boolean field) 的存在，必須寫成 +validates_inclusion_of :field_name, :in => [true, false]+ 。

+validates_presence_of+ 預設的錯誤訊息是 "_can't be empty_" 。

h4. +validates_uniqueness_of+ （確保屬性值是唯一的）

在儲存物件的前一刻，驗證屬性的值，以確定它是唯一的。這個工具，並不會在資料庫中建立唯一限定 (uniqueness constraint) ，所以，可能會有兩個不同 database connections ，在同一個欄，存入了兩筆一樣的記錄 (records) 。要避免這個狀況，您必須為資料庫做一個 unique index 。

<ruby>
class Account < ActiveRecord::Base
  validates_uniqueness_of :email
end
</ruby>

這個驗證的運作方式，是在 model 的資料表內，執行一個 SQL 查詢 (query) 。如此，會在現有的記錄 (record) 裡面，針對指定的屬性，搜尋相同的值。

要把唯一值檢查 (uniqueness check) 加上其他檢查條件的話，需要用到一些額外的屬性。這些屬性，可以用 +:scope+ 選項來指定：

<ruby>
class Holiday < ActiveRecord::Base
  validates_uniqueness_of :name, :scope => :year,
    :message => "should happen once per year"
end
</ruby>

另外，還有個 +:case_sensitive+ 選項，可以設定唯一值的檢查是否要分大小寫 (case sensitive) 。預設是 true 。

<ruby>
class Person < ActiveRecord::Base
  validates_uniqueness_of :name, :case_sensitive => false
end
</ruby>

WARNING. 有些資料庫，??? 設定成不管怎樣，都會執行不分大小寫的搜尋 are configured to perform case-insensitive searches anyway.

+validates_uniqueness_of+ 預設的錯誤訊息是 "_has already been taken_" 。

h4. +validates_with+ （用另外的類別來做驗證）

把記錄 (record) 轉交給另一個獨立的類別 (separate class) 來驗證。

<ruby>
class Person < ActiveRecord::Base
  validates_with GoodnessValidator
end

class GoodnessValidator < ActiveRecord::Validator
  def validate
    if record.first_name == "Evil"
      record.errors[:base] << "This person is evil"
    end
  end
end
</ruby>

+validates_with+ 會用一個或多個類別，來進行驗證。它沒有預設的錯誤訊息，所以，必須用手動 (manual) 的方式，在 validator 類別的定義裡面，把錯誤訊息加入該筆記錄 (record) 的錯誤訊息集合 (errors collection) 中。

validator 類別預設有兩個屬性：

* +record+ - 要驗證的那筆記錄 (record)
* +options+ - 已傳給 +validates_with+ 的額外選項 (extra options)

??? +validates_with+ 有 +:if+ 、+:unless+ 、+:on+ 這三個選項可用，這一點，就跟其他驗證方式一樣。如果有傳入其他選項，則會以 +options+ 的方式，送到 validator 類別去：???

<ruby>
class Person < ActiveRecord::Base
  validates_with GoodnessValidator, :fields => [:first_name, :last_name]
end

class GoodnessValidator < ActiveRecord::Validator
  def validate
    if options[:fields].any?{|field| record.send(field) == "Evil" }
      record.errors[:base] << "This person is evil"
    end
  end
end
</ruby>

h4. +validates_each+ （用區塊來做自訂的驗證）

按照區塊 (block) 裡的程式碼，對屬性 (attributes) 做驗證。這個工具，沒有定義任何驗證功能，您要自己用區塊 (block) 來撰寫驗證，然後，每一個傳給 (passed to) +validates_each+ 的屬性，都會根據您的區塊內容來做測試。下面示範，希望 names 跟 surnames 不是小寫開頭：

<ruby>
class Person < ActiveRecord::Base
  validates_each :name, :surname do |model, attr, value|
    model.errors.add(attr, 'must start with upper case') if value =~ /\A[a-z]/
  end
end
</ruby>

區塊接收了三樣東西：模型、屬性名稱、屬性的值。在區塊內，可以做任何您想做的驗證。要是驗證失敗，可以在 model 裡加入錯誤訊息，讓它變成無效的 (invalid) 。

h3. 共用的驗證選項 Common Validation Options

There are some common options that all the validation helpers can use. Here they are, except for the +:if+ and +:unless+ options, which are discussed later in "Conditional Validation":#conditional-validation.

h4. +:allow_nil+

The +:allow_nil+ option skips the validation when the value being validated is +nil+. Using +:allow_nil+ with +validates_presence_of+ allows for +nil+, but any other +blank?+ value will still be rejected.

<ruby>
class Coffee < ActiveRecord::Base
  validates_inclusion_of :size, :in => %w(small medium large),
    :message => "%{value} is not a valid size", :allow_nil => true
end
</ruby>

h4. +:allow_blank+

The +:allow_blank+ option is similar to the +:allow_nil+ option. This option will let validation pass if the attribute's value is +blank?+, like +nil+ or an empty string for example.

<ruby>
class Topic < ActiveRecord::Base
  validates_length_of :title, :is => 5, :allow_blank => true
end

Topic.create("title" => "").valid? # => true
Topic.create("title" => nil).valid? # => true
</ruby>

h4. +:message+

As you've already seen, the +:message+ option lets you specify the message that will be added to the +errors+ collection when validation fails. When this option is not used, Active Record will use the respective default error message for each validation helper.

h4. +:on+

The +:on+ option lets you specify when the validation should happen. The default behavior for all the built-in validation helpers is to be run on save (both when you're creating a new record and when you're updating it). If you want to change it, you can use +:on => :create+ to run the validation only when a new record is created or +:on => :update+ to run the validation only when a record is updated.

<ruby>
class Person < ActiveRecord::Base

  # it will be possible to update email with a duplicated value
  validates_uniqueness_of :email, :on => :create

  # it will be possible to create the record with a non-numerical age
  validates_numericality_of :age, :on => :update

  # the default (validates on both create and update)
  validates_presence_of :name, :on => :save
end
</ruby>

h3. Conditional Validation

Sometimes it will make sense to validate an object just when a given predicate is satisfied. You can do that by using the +:if+ and +:unless+ options, which can take a symbol, a string or a +Proc+. You may use the +:if+ option when you want to specify when the validation *should* happen. If you want to specify when the validation *should not* happen, then you may use the +:unless+ option.

h4. Using a Symbol with +:if+ and +:unless+

You can associate the +:if+ and +:unless+ options with a symbol corresponding to the name of a method that will get called right before validation happens. This is the most commonly used option.

<ruby>
class Order < ActiveRecord::Base
  validates_presence_of :card_number, :if => :paid_with_card?

  def paid_with_card?
    payment_type == "card"
  end
end
</ruby>

h4. Using a String with +:if+ and +:unless+

You can also use a string that will be evaluated using +eval+ and needs to contain valid Ruby code. You should use this option only when the string represents a really short condition.

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :surname, :if => "name.nil?"
end
</ruby>

h4. Using a Proc with +:if+ and +:unless+

Finally, it's possible to associate +:if+ and +:unless+ with a +Proc+ object which will be called. Using a +Proc+ object gives you the ability to write an inline condition instead of a separate method. This option is best suited for one-liners.

<ruby>
class Account < ActiveRecord::Base
  validates_confirmation_of :password,
    :unless => Proc.new { |a| a.password.blank? }
end
</ruby>

h3. Creating Custom Validation Methods

When the built-in validation helpers are not enough for your needs, you can write your own validation methods.

Simply create methods that verify the state of your models and add messages to the +errors+ collection when they are invalid. You must then register these methods by using one or more of the +validate+, +validate_on_create+ or +validate_on_update+ class methods, passing in the symbols for the validation methods' names.

You can pass more than one symbol for each class method and the respective validations will be run in the same order as they were registered.

<ruby>
class Invoice < ActiveRecord::Base
  validate :expiration_date_cannot_be_in_the_past,
    :discount_cannot_be_greater_than_total_value

  def expiration_date_cannot_be_in_the_past
    errors.add(:expiration_date, "can't be in the past") if
      !expiration_date.blank? and expiration_date < Date.today
  end

  def discount_cannot_be_greater_than_total_value
    errors.add(:discount, "can't be greater than total value") if
      discount > total_value
  end
end
</ruby>

You can even create your own validation helpers and reuse them in several different models. For example, an application that manages surveys may find it useful to express that a certain field corresponds to a set of choices:

<ruby>
ActiveRecord::Base.class_eval do
  def self.validates_as_choice(attr_name, n, options={})
    validates_inclusion_of attr_name, {:in => 1..n}.merge(options)
  end
end
</ruby>

Simply reopen +ActiveRecord::Base+ and define a class method like that. You'd typically put this code somewhere in +config/initializers+. You can use this helper like this:

<ruby>
class Movie < ActiveRecord::Base
  validates_as_choice :rating, 5
end
</ruby>

h3. Working with Validation Errors

In addition to the +valid?+ and +invalid?+ methods covered earlier, Rails provides a number of methods for working with the +errors+ collection and inquiring about the validity of objects.

The following is a list of the most commonly used methods. Please refer to the +ActiveRecord::Errors+ documentation for a list of all the available methods.

h4(#working_with_validation_errors-errors). +errors+

Returns an OrderedHash with all errors. Each key is the attribute name and the value is an array of strings with all errors.

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name
  validates_length_of :name, :minimum => 3
end

person = Person.new
person.valid? # => false
person.errors
 # => {:name => ["can't be blank", "is too short (minimum is 3 characters)"]}

person = Person.new(:name => "John Doe")
person.valid? # => true
person.errors # => []
</ruby>

h4(#working_with_validation_errors-errors-2). +errors[]+

+errors[]+ is used when you want to check the error messages for a specific attribute. It returns an array of strings with all error messages for the given attribute, each string with one error message. If there are no errors related to the attribute, it returns an empty array.

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name
  validates_length_of :name, :minimum => 3
end

person = Person.new(:name => "John Doe")
person.valid? # => true
person.errors[:name] # => []

person = Person.new(:name => "JD")
person.valid? # => false
person.errors[:name] # => ["is too short (minimum is 3 characters)"]

person = Person.new
person.valid? # => false
person.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]
</ruby>

h4. +errors.add+

The +add+ method lets you manually add messages that are related to particular attributes. You can use the +errors.full_messages+ or +errors.to_a+ methods to view the messages in the form they might be displayed to a user. Those particular messages get the attribute name prepended (and capitalized). +add+ receives the name of the attribute you want to add the message to, and the message itself.

<ruby>
class Person < ActiveRecord::Base
  def a_method_used_for_validation_purposes
    errors.add(:name, "cannot contain the characters !@#%*()_-+=")
  end
end

person = Person.create(:name => "!@#")

person.errors[:name]
 # => ["cannot contain the characters !@#%*()_-+="]

person.errors.full_messages
 # => ["Name cannot contain the characters !@#%*()_-+="]
</ruby>

Another way to do this is using +[]=+ setter

<ruby>
  class Person < ActiveRecord::Base
    def a_method_used_for_validation_purposes
      errors[:name] = "cannot contain the characters !@#%*()_-+="
    end
  end

  person = Person.create(:name => "!@#")

  person.errors[:name]
   # => ["cannot contain the characters !@#%*()_-+="]

  person.errors.to_a
   # => ["Name cannot contain the characters !@#%*()_-+="]
</ruby>

h4. +errors[:base]+

You can add error messages that are related to the object's state as a whole, instead of being related to a specific attribute. You can use this method when you want to say that the object is invalid, no matter the values of its attributes. Since +errors[:base]+ is an array, you can simply add a string to the array and uses it as the error message.

<ruby>
class Person < ActiveRecord::Base
  def a_method_used_for_validation_purposes
    errors[:base] << "This person is invalid because ..."
  end
end
</ruby>



h4. +errors.clear+

The +clear+ method is used when you intentionally want to clear all the messages in the +errors+ collection. Of course, calling +errors.clear+ upon an invalid object won't actually make it valid: the +errors+ collection will now be empty, but the next time you call +valid?+ or any method that tries to save this object to the database, the validations will run again. If any of the validations fail, the +errors+ collection will be filled again.

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name
  validates_length_of :name, :minimum => 3
end

person = Person.new
person.valid? # => false
person.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]

person.errors.clear
person.errors.empty? # => true

p.save # => false

p.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]
</ruby>

h4. +errors.size+

The +size+ method returns the total number of error messages for the object.

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name
  validates_length_of   :name, :minimum => 3
  validates_presence_of :email
end

person = Person.new
person.valid? # => false
person.errors.size # => 3

person = Person.new(:name => "Andrea", :email => "andrea@example.com")
person.valid? # => true
person.errors.size # => 0
</ruby>

h3. Displaying Validation Errors in the View

Rails provides built-in helpers to display the error messages of your models in your view templates.

h4. +error_messages+ and +error_messages_for+

When creating a form with the +form_for+ helper, you can use the +error_messages+ method on the form builder to render all failed validation messages for the current model instance.

<ruby>
class Product < ActiveRecord::Base
  validates_presence_of :description, :value
  validates_numericality_of :value, :allow_nil => true
end
</ruby>

<erb>
<%= form_for(@product) do |f| %>
  <%= f.error_messages %>
  <p>
    <%= f.label :description %><br />
    <%= f.text_field :description %>
  </p>
  <p>
    <%= f.label :value %><br />
    <%= f.text_field :value %>
  </p>
  <p>
    <%= f.submit "Create" %>
  </p>
<% end %>
</erb>

To get the idea, if you submit the form with empty fields you typically get this back, though styles are indeed missing by default:

!images/error_messages.png(Error messages)!

You can also use the +error_messages_for+ helper to display the error messages of a model assigned to a view template. It's very similar to the previous example and will achieve exactly the same result.

<erb>
<%= error_messages_for :product %>
</erb>

The displayed text for each error message will always be formed by the capitalized name of the attribute that holds the error, followed by the error message itself.

Both the +form.error_messages+ and the +error_messages_for+ helpers accept options that let you customize the +div+ element that holds the messages, changing the header text, the message below the header text and the tag used for the element that defines the header.

<erb>
<%= f.error_messages :header_message => "Invalid product!",
  :message => "You'll need to fix the following fields:",
  :header_tag => :h3 %>
</erb>

Which results in the following content:

!images/customized_error_messages.png(Customized error messages)!

If you pass +nil+ to any of these options, it will get rid of the respective section of the +div+.

h4. Customizing the Error Messages CSS

The selectors to customize the style of error messages are:

* +.field_with_errors+ - Style for the form fields and labels with errors.
* +#errorExplanation+ - Style for the +div+ element with the error messages.
* +#errorExplanation h2+ - Style for the header of the +div+ element.
* +#errorExplanation p+ - Style for the paragraph that holds the message that appears right below the header of the +div+ element.
* +#errorExplanation ul li+ - Style for the list items with individual error messages.

Scaffolding for example generates +public/stylesheets/scaffold.css+, which defines the red-based style you saw above.

The name of the class and the id can be changed with the +:class+ and +:id+ options, accepted by both helpers.

h4. Customizing the Error Messages HTML

By default, form fields with errors are displayed enclosed by a +div+ element with the +field_with_errors+ CSS class. However, it's possible to override that.

The way form fields with errors are treated is defined by +ActionView::Base.field_error_proc+. This is a +Proc+ that receives two parameters:

* A string with the HTML tag
* An instance of +ActionView::Helpers::InstanceTag+.

Here is a simple example where we change the Rails behaviour to always display the error messages in front of each of the form fields with errors. The error messages will be enclosed by a +span+ element with a +validation-error+ CSS class. There will be no +div+ element enclosing the +input+ element, so we get rid of that red border around the text field. You can use the +validation-error+ CSS class to style it anyway you want.

<ruby>
ActionView::Base.field_error_proc = Proc.new do |html_tag, instance|
  if instance.error_message.kind_of?(Array)
    %(#{html_tag}<span class="validation-error">&nbsp;
      #{instance.error_message.join(',')}</span>)
  else
    %(#{html_tag}<span class="validation-error">&nbsp;
      #{instance.error_message}</span>)
  end
end
</ruby>

This will result in something like the following:

!images/validation_error_messages.png(Validation error messages)!

h3. Callbacks Overview

Callbacks are methods that get called at certain moments of an object's life cycle. With callbacks it's possible to write code that will run whenever an Active Record object is created, saved, updated, deleted, validated, or loaded from the database.

h4. Callback Registration

In order to use the available callbacks, you need to register them. You can do that by implementing them as ordinary methods, and then using a macro-style class method to register them as callbacks.

<ruby>
class User < ActiveRecord::Base
  validates_presence_of :login, :email

  before_validation :ensure_login_has_a_value

  protected
  def ensure_login_has_a_value
    if login.nil?
      self.login = email unless email.blank?
    end
  end
end
</ruby>

The macro-style class methods can also receive a block. Consider using this style if the code inside your block is so short that it fits in just one line.

<ruby>
class User < ActiveRecord::Base
  validates_presence_of :login, :email

  before_create {|user| user.name = user.login.capitalize
	if user.name.blank?}
end
</ruby>

It's considered good practice to declare callback methods as being protected or private. If left public, they can be called from outside of the model and violate the principle of object encapsulation.

h3. Available Callbacks

Here is a list with all the available Active Record callbacks, listed in the same order in which they will get called during the respective operations:

h4. Creating an Object

* +before_validation+
* +after_validation+
* +before_save+
* +after_save+
* +before_create+
* +around_create+
* +after_create+

h4. Updating an Object

* +before_validation+
* +after_validation+
* +before_save+
* +after_save+
* +before_update+
* +around_update+
* +after_update+

h4. Destroying an Object

* +before_destroy+
* +after_destroy+
* +around_destroy+

WARNING. +after_save+ runs both on create and update, but always _after_ the more specific callbacks +after_create+ and +after_update+, no matter the order in which the macro calls were executed.

h4. +after_initialize+ and +after_find+

The +after_initialize+ callback will be called whenever an Active Record object is instantiated, either by directly using +new+ or when a record is loaded from the database. It can be useful to avoid the need to directly override your Active Record +initialize+ method.

The +after_find+ callback will be called whenever Active Record loads a record from the database. +after_find+ is called before +after_initialize+ if both are defined.

The +after_initialize+ and +after_find+ callbacks are a bit different from the others. They have no +before_*+ counterparts, and the only way to register them is by defining them as regular methods. If you try to register +after_initialize+ or +after_find+ using macro-style class methods, they will just be ignored. This behaviour is due to performance reasons, since +after_initialize+ and +after_find+ will both be called for each record found in the database, significantly slowing down the queries.

<ruby>
class User < ActiveRecord::Base
  def after_initialize
    puts "You have initialized an object!"
  end

  def after_find
    puts "You have found an object!"
  end
end

>> User.new
You have initialized an object!
=> #<User id: nil>

>> User.first
You have found an object!
You have initialized an object!
=> #<User id: 1>
</ruby>

h3. Running Callbacks

The following methods trigger callbacks:


* +create+
* +create!+
* +decrement!+
* +destroy+
* +destroy_all+
* +increment!+
* +save+
* +save!+
* +save(false)+
* +toggle!+
* +update+
* +update_attribute+
* +update_attributes+
* +update_attributes!+
* +valid?+

Additionally, the +after_find+ callback is triggered by the following finder methods:

* +all+
* +first+
* +find+
* +find_all_by_<em>attribute</em>+
* +find_by_<em>attribute</em>+
* +find_by_<em>attribute</em>!+
* +last+

The +after_initialize+ callback is triggered every time a new object of the class is initialized.

h3. Skipping Callbacks

Just as with validations, it's also possible to skip callbacks. These methods should be used with caution, however, because important business rules and application logic may be kept in callbacks. Bypassing them without understanding the potential implications may lead to invalid data.

* +decrement+
* +decrement_counter+
* +delete+
* +delete_all+
* +find_by_sql+
* +increment+
* +increment_counter+
* +toggle+
* +update_all+
* +update_counters+

h3. Halting Execution

As you start registering new callbacks for your models, they will be queued for execution. This queue will include all your model's validations, the registered callbacks, and the database operation to be executed.

The whole callback chain is wrapped in a transaction. If any <em>before</em> callback method returns exactly +false+ or raises an exception the execution chain gets halted and a ROLLBACK is issued; <em>after</em> callbacks can only accomplish that by raising an exception.

WARNING. Raising an arbitrary exception may break code that expects +save+ and friends not to fail like that. The +ActiveRecord::Rollback+ exception is thought precisely to tell Active Record a rollback is going on. That one is internally captured but not reraised.

h3. Relational Callbacks

Callbacks work through model relationships, and can even be defined by them. Let's take an example where a user has many posts. In our example, a user's posts should be destroyed if the user is destroyed. So, we'll add an +after_destroy+ callback to the +User+ model by way of its relationship to the +Post+ model.

<ruby>
class User < ActiveRecord::Base
  has_many :posts, :dependent => :destroy
end

class Post < ActiveRecord::Base
  after_destroy :log_destroy_action

  def log_destroy_action
    puts 'Post destroyed'
  end
end

>> user = User.first
=> #<User id: 1>
>> user.posts.create!
=> #<Post id: 1, user_id: 1>
>> user.destroy
Post destroyed
=> #<User id: 1>
</ruby>

h3. Conditional Callbacks

Like in validations, we can also make our callbacks conditional, calling them only when a given predicate is satisfied. You can do that by using the +:if+ and +:unless+ options, which can take a symbol, a string or a +Proc+. You may use the +:if+ option when you want to specify when the callback *should* get called. If you want to specify when the callback *should not* be called, then you may use the +:unless+ option.

h4. Using +:if+ and +:unless+ with a Symbol

You can associate the +:if+ and +:unless+ options with a symbol corresponding to the name of a method that will get called right before the callback. When using the +:if+ option, the callback won't be executed if the method returns false; when using the +:unless+ option, the callback won't be executed if the method returns true. This is the most common option. Using this form of registration it's also possible to register several different methods that should be called to check if the callback should be executed.

<ruby>
class Order < ActiveRecord::Base
  before_save :normalize_card_number, :if => :paid_with_card?
end
</ruby>

h4. Using +:if+ and +:unless+ with a String

You can also use a string that will be evaluated using +eval+ and needs to contain valid Ruby code. You should use this option only when the string represents a really short condition.

<ruby>
class Order < ActiveRecord::Base
  before_save :normalize_card_number, :if => "paid_with_card?"
end
</ruby>

h4. Using +:if+ and +:unless+ with a Proc

Finally, it's possible to associate +:if+ and +:unless+ with a +Proc+ object. This option is best suited when writing short validation methods, usually one-liners.

<ruby>
class Order < ActiveRecord::Base
  before_save :normalize_card_number,
    :if => Proc.new { |order| order.paid_with_card? }
end
</ruby>

h4. Multiple Conditions for Callbacks

When writing conditional callbacks, it's possible to mix both +:if+ and +:unless+ in the same callback declaration.

<ruby>
class Comment < ActiveRecord::Base
  after_create :send_email_to_author, :if => :author_wants_emails?,
    :unless => Proc.new { |comment| comment.post.ignore_comments? }
end
</ruby>

h3. Callback Classes

Sometimes the callback methods that you'll write will be useful enough to be reused by other models. Active Record makes it possible to create classes that encapsulate the callback methods, so it becomes very easy to reuse them.

Here's an example where we create a class with an +after_destroy+ callback for a +PictureFile+ model.

<ruby>
class PictureFileCallbacks
  def after_destroy(picture_file)
    File.delete(picture_file.filepath)
      if File.exists?(picture_file.filepath)
  end
end
</ruby>

When declared inside a class the callback method will receive the model object as a parameter. We can now use it this way:

<ruby>
class PictureFile < ActiveRecord::Base
  after_destroy PictureFileCallbacks.new
end
</ruby>

Note that we needed to instantiate a new +PictureFileCallbacks+ object, since we declared our callback as an instance method. Sometimes it will make more sense to have it as a class method.

<ruby>
class PictureFileCallbacks
  def self.after_destroy(picture_file)
    File.delete(picture_file.filepath)
      if File.exists?(picture_file.filepath)
  end
end
</ruby>

If the callback method is declared this way, it won't be necessary to instantiate a +PictureFileCallbacks+ object.

<ruby>
class PictureFile < ActiveRecord::Base
  after_destroy PictureFileCallbacks
end
</ruby>

You can declare as many callbacks as you want inside your callback classes.

h3. Observers

Observers are similar to callbacks, but with important differences. Whereas callbacks can pollute a model with code that isn't directly related to its purpose, observers allow you to add the same functionality outside of a model. For example, it could be argued that a +User+ model should not include code to send registration confirmation emails. Whenever you use callbacks with code that isn't directly related to your model, you may want to consider creating an observer instead.

h4. Creating Observers

For example, imagine a +User+ model where we want to send an email every time a new user is created. Because sending emails is not directly related to our model's purpose, we could create an observer to contain this functionality.

<shell>
rails generate observer User
</shell>

<ruby>
class UserObserver < ActiveRecord::Observer
  def after_create(model)
    # code to send confirmation email...
  end
end
</ruby>

As with callback classes, the observer's methods receive the observed model as a parameter.

h4. Registering Observers

Observers are conventionally placed inside of your +app/models+ directory and registered in your application's +config/environment.rb+ file. For example, the +UserObserver+ above would be saved as +app/models/user_observer.rb+ and registered in +config/environment.rb+ this way:

<ruby>
# Activate observers that should always be running
config.active_record.observers = :user_observer
</ruby>

As usual, settings in +config/environments+ take precedence over those in +config/environment.rb+. So, if you prefer that an observer doesn't run in all environments, you can simply register it in a specific environment instead.

h4. Sharing Observers

By default, Rails will simply strip "Observer" from an observer's name to find the model it should observe. However, observers can also be used to add behaviour to more than one model, and so it's possible to manually specify the models that our observer should observe.

<ruby>
class MailerObserver < ActiveRecord::Observer
  observe :registration, :user

  def after_create(model)
    # code to send confirmation email...
  end
end
</ruby>

In this example, the +after_create+ method would be called whenever a +Registration+ or +User+ was created. Note that this new +MailerObserver+ would also need to be registered in +config/environment.rb+ in order to take effect.

<ruby>
# Activate observers that should always be running
config.active_record.observers = :mailer_observer
</ruby>

h3. Changelog

"Lighthouse ticket":http://rails.lighthouseapp.com/projects/16213/tickets/26-active-record-validations-and-callbacks

* July 20, 2010: Fixed typos and rephrased some paragraphs for clarity. "Jaime Iniesta":http://jaimeiniesta.com
* May 24, 2010: Fixed document to validate XHTML 1.0 Strict. "Jaime Iniesta":http://jaimeiniesta.com
* May 15, 2010: Validation Errors section updated by "Emili Parreño":http://www.eparreno.com
* March 7, 2009: Callbacks revision by Trevor Turk
* February 10, 2009: Observers revision by Trevor Turk
* February 5, 2009: Initial revision by Trevor Turk
* January 9, 2009: Initial version by "Cássio Marques":credits.html#cmarques
