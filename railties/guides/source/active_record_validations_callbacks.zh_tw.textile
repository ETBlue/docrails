h2. Active Record 的驗證 (Validations) 與回呼 (Callbacks)

這一章說明如何 ??? hook into ??? Active Record 物件的生命週期：在物件進入資料庫之前，驗證它的狀態，以及，在物件生命週期的特定時間點，執行自訂的操作。

讀完本篇，您會：

* 了解 Active Record 物件的生命週期 (life cycle)
* 使用內建的 Active Record 驗證輔助工具 (validation helpers)
* 打造您自訂的驗證方法 (validation methods)
* 處理驗證過程中所產生的錯誤訊息 (error messages)
* 撰寫回呼方法 (callback methods) ，以便回應物件生命週期中所發生的事件 (events)
* 撰寫特殊類別 (special classes) ，以便封裝 (encapsulate) 回呼之間的共通行為 (common behavior)
* 建立觀測器 (observers)，以便在原始類別 (original class) 的外部，回應物件生命週期中所發生的的事件 (events)

endprologue.

h3. 物件生命週期 (Object Life Cycle)

Rails 正常操作的期間，會產生一些物件，也會更新、銷毀它們。為此，Active Record 提供了 <em>object life cycle</em> 內的 ??? hooks，讓您可以操控程式、操控資料。

驗證 (validations) 的功用，是確保只有有效的資料，存到資料庫裡面。而回呼 (callbacks) 和觀測器 (observers) 的功用，則是在物件狀態變化 (alteration) 之前、或變化之後，觸發相關的邏輯 (logic) 。

h3. 驗證的概觀 (Validations Overview)

深入 Rails 的驗證 (validations) 細節前，先來了解一下驗證所扮演的角色。

h4. 為什麼要驗證 (Why Use Validations) ？

驗證 (validations) 的作用，是確保資料庫裡，只有有效資料 (valid data) 才會儲存進去。比方說，您的應用程式可能要確定每個使用者，都提供有效的電子郵件地址、和郵寄地址等。

資料存進資料庫前，有幾個驗證的方法，包括：原生的資料庫約束 (native database constraints) 、客戶端驗證 (client-side validations) 、控制器層級的驗證 (controller-level validations) 、以及 model 層級的驗證 (model-level validations)。

* 資料庫約束 (database constraints) 也稱作預存程序 (stored procedures) ，這些驗證機制，要依賴特定的資料庫系統，所以測試和維護會比較難。不過，如果資料庫也要讓別的應用程式使用，那在資料庫層做約束可能就是不錯的主意。另外，資料庫層級的驗證可以很安全的處理一些事情，像是在重度使用的資料表中，確保唯一值 (uniqueness) 之類的。這些事情，如果用其他的方法，會比較難實作。
* 客戶端的驗證 (client-side validations) 雖然可以用，但單單用它的話通常不太可靠。如果用 JavaScript 來實作，要是使用者的瀏覽器把 JavaScript 關掉，那驗證就被跳過了。不過畢竟，客戶端驗證可以給使用者很即時的回饋，所以，要是能跟其他驗證手法併用，那倒是挺方便的。
* 控制器層級的驗證 (controller-level validations) ，也可以用用看，但它常常會變得很笨重，不好測試跟維護。不管怎樣，"keep your controllers skinny":http://weblog.jamisbuck.org/2006/10/18/skinny-controller-fat-model 總是好的，長遠的說，可以讓程式用起來很愉快。
* model 層級的驗證 (model-level validations) 是最佳的作法。這種驗證方式，不用受制於特定的資料庫系統，也不會被使用者跳過，測試起來很方便，也容易維護。為了方便大家使用 model 層級的驗證，Rails 針對常見的驗證需求，內建了輔助工具，當然，您也可以撰寫自己的驗證方法。

h4. 什麼時候會發生驗證 (When Does Validation Happen) ？

Active Record 類別底下，有兩種物件：一種是跟資料庫中的某一行對應的，另一種則是沒有跟資料對應的。當您用 +new+ 之類的方法，建立了一個新物件，此時，它還不屬於資料庫。等到您呼叫那個物件的 +save+ 方法，它才會被存入適當的資料表中。至於物件目前是否已存入資料庫，則是用 Active Record 的實體方法 (instance method) +new_record?+ 來確認。簡單舉例，這裡有個 Active Record 底下的類別：

<ruby>
class Person < ActiveRecord::Base
end
</ruby>

從 +rails console+ 的輸出結果，可以看出它的運作方式：

<shell>
>> p = Person.new(:name => "John Doe")
=> #<Person id: nil, name: "John Doe", created_at: nil, :updated_at: nil>
>> p.new_record?
=> true
>> p.save
=> true
>> p.new_record?
=> false
</shell>

一筆新記錄 (record) 的新增與儲存，會對資料庫送出一個 SQL 的 +INSERT+ 操作 (operation) 。現有記錄的更新，則會送出 +UPDATE+ 操作。通常，在這些命令送到資料庫之前，會進行驗證，如果有任一個驗證失敗的話，這個物件就標記為無效 (marked as invalid) ，於是 Active Record 就不會執行 +INSERT+ 或 +UPDATE+ ，所以，無效的物件也就不會存進資料庫。您可以針對物件的新增、儲存、更新，自訂專屬的驗證功能。

CAUTION: 在資料庫裡面，有很多種方法，都能改變物件的狀態 (state) 。這些方法中，有些會觸發驗證機制，有些則不會。也就是說，不注意的話，是有可能把無效狀態 (invalid state) 的物件，存到資料庫裡去的。

下面列出的方法，會觸發驗證，只有驗證合格的物件才會存入資料庫：

* +create+
* +create!+
* +save+
* +save!+
* +update+
* +update_attributes+
* +update_attributes!+

尾巴附有一個驚嘆號的版本 (bang versions) 像是 +save!+ ，會在這筆紀錄 invalid 的時候丟出例外 (raise an exception) 。沒有驚嘆號的 (non-bang versions) 則不會丟出例外。其中， +save+ 跟 +update_attributes+ 會傳回 +false+ ，而 +create+ 跟 +update+ 則單純的傳回物件本身。

h4. 略過驗證 (Skipping Validations)

下面列出的方法會略過驗證，不管物件是否有效，都會將它存到資料庫中。所以，要小心使用。

* +decrement!+
* +decrement_counter+
* +increment!+
* +increment_counter+
* +toggle!+
* +update_all+
* +update_attribute+
* +update_counters+

如果，把 +:validate => false+ 當作引數 (argument) 傳入的話， +save+ 也是可以略過驗證的。這個技巧也是要小心使用。

* +save(:validate => false)+

h4. +valid?+ 與 +invalid?+ 檢查是否有錯誤訊息

Rails 用 +valid?+ 方法，來確認物件是否有效，而您也可以自己使用它。 +valid?+ 會觸發驗證，如果驗證完，沒有錯誤訊息附加到物件上的話，就傳回真值 (true) ，反之，有錯誤訊息的話，就是假值 (false) 。

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name
end

Person.create(:name => "John Doe").valid? # => true
Person.create(:name => nil).valid? # => false
</ruby>

Active Record 在執行驗證的時候，任何的錯誤訊息，都可以用 +errors+ 這個實體方法 (instance method) 來存取 (accessed) 。驗證結束後，如果這個集合 (collection) 仍然是空的，那在定義上，這個物件就會被認為是有效的 (valid) 。

要注意的是，用 +new+ 實體化 (instantiated) 出來的物件，即使它在技術上是無效 (invalid) 的，也不會回報錯誤訊息，因為，執行 +new+ 的時候，並不會進行驗證。

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name
end

>> p = Person.new
=> #<Person id: nil, name: nil>
>> p.errors
=> {}

>> p.valid?
=> false
>> p.errors
=> {:name=>["can't be blank"]}

>> p = Person.create
=> #<Person id: nil, name: nil>
>> p.errors
=> {:name=>["can't be blank"]}

>> p.save
=> false

>> p.save!
=> ActiveRecord::RecordInvalid: Validation failed: Name can't be blank

>> Person.create!
=> ActiveRecord::RecordInvalid: Validation failed: Name can't be blank
</ruby>

+invalid?+ 純粹是 +valid?+ 的相反， +invalid?+ 會觸發驗證，如果有任何錯誤訊息加到物件上，就傳回真值 (true) ， 反之則是假值 (false) 。

h4(#validations_overview-errors). +errors[]+ 屬性內，錯誤訊息的陣列集合

對於物件的某個屬性 (attribute) ，要確認是否有效 (valid) ，可以用 +errors[:attribute]+ ，它會傳回一個陣列 (array) ，裡面有該屬性全部的錯誤訊息 (attribute errors) 。如果，此屬性沒有任何錯誤訊息，那就會傳回空的陣列。

這個方法，要在驗證執行過 _之後_ 才能使用，因為，它只會檢查錯誤訊息的集合 (errors collection) ，而不會觸發驗證本身。這跟上面提過的 +ActiveRecord::Base#invalid?+ 方法，是不一樣的，因為 +errors[:attribute]+ 不會確認物件整體上的有效性 (validity) ，它只是檢查這個物件的某個屬性，有沒有錯誤訊息而已。

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name
end

>> Person.new.errors[:name].any? # => false
>> Person.create.errors[:name].any? # => true
</ruby>

關於驗證的錯誤訊息 (validation errors) ，之後的 "Working with Validation Errors":#working-with-validation-errors 章節會再深入解釋。現在，讓我們回頭看看 Rails 內建的驗證輔助工具 (validation helpers) 。

h3. 驗證輔助工具 (Validation Helpers)

Active Record 提供許多預先定義 (pre-defined) 的驗證輔助工具，您可以在類別定義 (class definitions) 中，直接使用它們。這些輔助工具有共通的驗證規則，每當一個驗證失敗，就會在該物件的 +errors+ 集合中，加入一條錯誤訊息，此訊息，跟這個驗證失敗的欄位 (field) 相關連 (associated) 。

每個輔助工具，可以接收 (accepts) 任意數量的屬性名稱 (attribute names) 。所以，只要用一行程式碼，就可以把同一種驗證方式，套用到好幾個不同的屬性上面。

所有輔助工具都會接收 +:on+ 跟 +:message+ 選項 (options) ，這些選項，會定義驗證該何時執行，以及，如果驗證失敗的話，該加什麼訊息到 +errors+ 集合中, respectively 。選項 +:on+ 的作用，是將一個值 +:save+ （預設），或者 +:create+ ，或者 +:update+ 。至於選項 +:message+ 的作用，則是自訂錯誤訊息，如果，沒有自訂 +:message+ ，就會採用預設的，反正，每個驗證輔助工具，都有預設的訊息可以用。底下讓我們一個一個來看。

h4. +validates_acceptance_of+ 確定使用者已經接受

當使用者送出表單 (form submitted) 時，針對使用者介面中的核取方塊 (checkbox) ，驗證它有沒有勾選。會用到的地方，通常是應用程式的服務條款 (terms of service) ，要使用者確認「我同意」、「我已閱讀」之類的。這種驗證，幾乎都是網路應用程式 (web applications) 在用。這個 'acceptance （是否已接受）' 不用記在資料庫裡，所以，沒有對應的欄位 (field) 也沒關係，輔助工具會建立一個虛擬的屬性 (virtual attribute) 來應付。

<ruby>
class Person < ActiveRecord::Base
  validates_acceptance_of :terms_of_service
end
</ruby>

+validates_acceptance_of+ 預設的錯誤訊息是 "_must be accepted_" 。

+validates_acceptance_of+ 可以接收 +:accept+ 選項，決定什麼值代表 acceptance （已接受），預設的值是 "1" ，您要改掉它也可以。

<ruby>
class Person < ActiveRecord::Base
  validates_acceptance_of :terms_of_service, :accept => 'yes'
end
</ruby>

h4. +validates_associated+ 驗證其他有關連的 models

如果您的 model ，跟其他 models 有關聯 (associations) ，而這些相關的 models 也需要驗證，那麼，就需要使用這個輔助工具了。使用 +validates_associated+ 後，當您儲存物件時，每一個跟它相關的物件，都會呼叫 +valid?+ 方法。

<ruby>
class Library < ActiveRecord::Base
  has_many :books
  validates_associated :books
end
</ruby>

所有的資料庫關聯類型 (association types) ，都可以使用這種驗證。

CAUTION: 不要在一個資料庫關聯的兩端，同時使用 +validates_associated+ ，因為，它們會一直互相呼叫，最後沒完沒了，停不下來。

+validates_associated+ 預設的錯誤訊息是 "_is invalid_" 。每個相關聯的物件 (associated object) 都有自己的 +errors+ 集合，自己的錯誤訊息，只會出現在自己的集合裡面，不會跑到呼叫方的 model (calling model) 裡面。

h4. +validates_confirmation_of+ 檢查使用者的再次確認

如果有兩個文字欄位 (text fields) ，必須收到一模一樣的內容，就會用到這個驗證，比方說，要使用者再確認一次 email address 或是 password 的時候。這個驗證功能，會建立一個虛擬屬性 (virtual attribute) ，虛擬屬性的名稱，就是把那個需要確認的欄位的名稱，尾巴後面再加上 "_confirmation" 。

<ruby>
class Person < ActiveRecord::Base
  validates_confirmation_of :email
end
</ruby>

使用這個驗證的時候，在視圖模板 (view template) 中，可以寫成：

<erb>
<%= text_field :person, :email %>
<%= text_field :person, :email_confirmation %>
</erb>

上面的檢查，只有在 +email_confirmation+ 不是空值 +nil+ 的時候，才會執行，所以，要檢查這個欄位的話，要事先確定 +email_confirmation+ 這個屬性是否存在 。關於這點，後面會在 +validates_presence_of+ 講到。

<ruby>
class Person < ActiveRecord::Base
  validates_confirmation_of :email
  validates_presence_of :email_confirmation
end
</ruby>

+validates_confirmation_of+ 預設的錯誤訊息是 "_doesn't match confirmation_" 。

h4. +validates_exclusion_of+ 確定屬性的值不在指定清單內

確認該屬性的值，沒有在指定的集合 (set) 中出現。這個集合，可以是任何一個內部資料可逐一列舉的 (enumerable) 物件。

<ruby>
class Account < ActiveRecord::Base
  validates_exclusion_of :subdomain, :in => %w(www),
    :message => "Subdomain %{value} is reserved."
end
</ruby>

+validates_exclusion_of+ 有個 +:in+ 的選項，會接收一組值，這組值，也就是被驗證的屬性，所不該接受的值。+:in+ 選項有個別名 (alias) 叫做 +:within+ ，功能是一樣的。上面的範例用 +:message+ 選項??? 來表現如何 include 屬性的值 ???。

+validates_exclusion_of+ 預設的錯誤訊息是 "_is reserved_" 。

h4. +validates_format_of+ 檢查屬性值的格式

這個工具，會測試屬性的值，是否符合 +:with+ 選項所指定的常規表示式 (regular expression) 。

<ruby>
class Product < ActiveRecord::Base
  validates_format_of :legacy_code, :with => /\A[a-zA-Z]+\z/,
    :message => "Only letters allowed"
end
</ruby>

+validates_format_of+ 預設的錯誤訊息是 "_is invalid_" 。

h4. +validates_inclusion_of+ 確定屬性的值在指定清單內

確認該屬性的值，有被包括在指定的 set 裡面，這個 set 可以是任何 enumerable 物件。

<ruby>
class Coffee < ActiveRecord::Base
  validates_inclusion_of :size, :in => %w(small medium large),
    :message => "%{value} is not a valid size"
end
</ruby>

+validates_inclusion_of+ 有個 +:in+ 選項，會接收一組值，就是被驗證的屬性，所能夠接受的值。 +:in+ 選項有個別名 (alias) 叫做 +:within+ ，功能是相同的。上面的範例用 +:message+ 選項來表現如何 include 屬性的值。

+validates_inclusion_of+ 預設的錯誤訊息是 "_is not included in the list_" 。

h4. +validates_length_of+ 確定長度在指定範圍內

驗證屬性值的長度。這個工具有多種選項 (options) ，所以，您有許多方法，可以指定長度限制 (length constraints) ：

<ruby>
class Person < ActiveRecord::Base
  validates_length_of :name, :minimum => 2
  validates_length_of :bio, :maximum => 500
  validates_length_of :password, :in => 6..20
  validates_length_of :registration_number, :is => 6
end
</ruby>

可用的選項，包括：

* +:minimum+ - 屬性的值不能比指定長度短。
* +:maximum+ - 屬性的值不能比指定長度長。
* +:in+ (or +:within+) - 屬性的值的長度，要在某個區間 (interval) 之內。所以，這個選項的值，必須是一個範圍 (range) 。
* +:is+ - 屬性的值的長度，要跟指定的長度相等。

不同類型的長度驗證，預設的錯誤訊息，也各自不同。要自訂錯誤訊息，可以用 +:wrong_length+ 、 +:too_long+ 、+:too_short+ 選項，搭配 <tt>%{count}</tt> 做為佔位符 (placeholder) ，留給跟長度限制有關的數字。同樣的，您可以用 +:message+ 選項來自訂錯誤訊息。

<ruby>
class Person < ActiveRecord::Base
  validates_length_of :bio, :maximum => 1000,
    :too_long => "%{count} characters is the maximum allowed"
end
</ruby>

預設狀態下，此工具會計算字元 (characters) ，不過，要用別的方式計算的話，您可以用 +:tokenizer+ 選項：

<ruby>
class Essay < ActiveRecord::Base
  validates_length_of :content,
    :minimum   => 300,
    :maximum   => 400,
    :tokenizer => lambda { |str| str.scan(/\w+/) },
    :too_short => "must have at least %{count} words",
    :too_long  => "must have at most %{count} words"
end
</ruby>

+validates_length_of+ 輔助工具，別名叫做 +validates_size_of+ 。

h4. +validates_numericality_of+ 確保屬性只包括數值

驗證您的屬性只包含數值 (numeric values) 。所謂的數值，要符合這樣的格式：一個可有可無的記號 (sign) 後面接一個整數 (integral) 或浮點數 (floating point number) 。如果只想允許整數，把 +:only_integer+ 設定為 true 就可以了。

如果 +:only_integer+ 設為 +true+ ，會用這個常規表示式

<ruby>
/\A[+-]?\d+\Z/
</ruby>

來驗證屬性的值。反之，如果沒設定，則會嘗試用 +Float+ 來把值轉換成數字。

WARNING. 上面的常規表示式，允許換行字元 (trailing newline character) 。

<ruby>
class Player < ActiveRecord::Base
  validates_numericality_of :points
  validates_numericality_of :games_played, :only_integer => true
end
</ruby>

除了 +:only_integer+ 之外， +validates_numericality_of+ 還接受下列這些選項，來限制允許的值 (acceptable values) ：

* +:greater_than+ - 必須比這個值還大。預設的錯誤訊息是 "_must be greater than %{count}_" 。
* +:greater_than_or_equal_to+ - 必須大於或等於這個值。預設的錯誤訊息是 "_must be greater than or equal to %{count}_" 。
* +:equal_to+ - 必須等於這個值。預設的錯誤訊息是 "_must be equal to %{count}_" 。
* +:less_than+ - 必須小於這個值。預設的錯誤訊息是 "_must be less than %{count}_" 。
* +:less_than_or_equal_to+ - 必須小於或等於這個值。預設的錯誤訊息是 "_must be less than or equal to %{count}_" 。
* +:odd+ - 如果設定為 true ，則被驗證的值必須是奇數。預設的錯誤訊息是 "_must be odd_" 。
* +:even+ - 如果設定為 true ，則被驗證的值必須是偶數。預設的錯誤訊息是 "_must be even_" 。

+validates_numericality_of+ 預設的錯誤訊息是 "_is not a number_" 。

h4. +validates_presence_of+ 確定屬性是存在的

驗證指定的屬性不是空的。此工具使用 +blank?+ 方法，去檢查屬性值是否為 +nil+ 或者空字串 (blank string) ，所謂空字串指的是沒有內容的 (empty) 、或者由空白字元 (whitespace) 組成的字串。

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name, :login, :email
end
</ruby>

如果，要確認資料庫關聯 (association) 的存在，那要測試的，是存不存在和資料庫關聯相對應的外部鍵 (foreign key) ，而不是相關聯的物件 (associated object) 本身。

<ruby>
class LineItem < ActiveRecord::Base
  belongs_to :order
  validates_presence_of :order_id
end
</ruby>

由於 +false.blank?+ 的結果是 true ，要驗證布林欄位 (boolean field) 的存在，必須寫成 +validates_inclusion_of :field_name, :in => [true, false]+ 。

+validates_presence_of+ 預設的錯誤訊息是 "_can't be empty_" 。

h4. +validates_uniqueness_of+ 確保屬性的值是唯一的

在儲存物件的前一刻，驗證屬性的值，以確定它是唯一的。這個工具，並不會在資料庫中建立唯一值約束 (uniqueness constraint) ，所以，可能會有兩個不同資料庫連結 (database connections) ，在同一個欄，存入了兩筆一樣的記錄 (records) 。要避免這個狀況，您必須為資料庫做一個 ??? 唯一索引 (unique index) 。

<ruby>
class Account < ActiveRecord::Base
  validates_uniqueness_of :email
end
</ruby>

這個驗證的運作方式，是在 model 的資料表內，執行一個 SQL 查詢 (query) 。如此，會在現有的記錄 (record) 裡面，針對指定的屬性，搜尋相同的值。

要把唯一值檢查 (uniqueness check) 加上其他檢查條件的話，需要用到一些額外的屬性。這些屬性，可以用 +:scope+ 選項來指定：

<ruby>
class Holiday < ActiveRecord::Base
  validates_uniqueness_of :name, :scope => :year,
    :message => "should happen once per year"
end
</ruby>

另外，還有個 +:case_sensitive+ 選項，可以設定唯一值的檢查是否要分大小寫 (case sensitive) 。預設是 true 。

<ruby>
class Person < ActiveRecord::Base
  validates_uniqueness_of :name, :case_sensitive => false
end
</ruby>

WARNING. 有些資料庫，設定成不論如何都會執行不分大小寫 (case-insensitive) 的搜尋。

+validates_uniqueness_of+ 預設的錯誤訊息是 "_has already been taken_" 。

h4. +validates_with+ 用另外的類別來做驗證

把記錄 (record) 轉交給另一個獨立的類別 (separate class) 來驗證。

<ruby>
class Person < ActiveRecord::Base
  validates_with GoodnessValidator
end

class GoodnessValidator < ActiveRecord::Validator
  def validate
    if record.first_name == "Evil"
      record.errors[:base] << "This person is evil"
    end
  end
end
</ruby>

+validates_with+ 會用一個或多個類別，來進行驗證。它沒有預設的錯誤訊息，所以，必須用手動 (manual) 的方式，在 validator 類別的定義裡面，把錯誤訊息加入該筆記錄 (record) 的錯誤訊息集合 (errors collection) 中。

validator 類別預設有兩個屬性：

* +record+ - 要驗證的那筆記錄 (record)
* +options+ - 已傳給 +validates_with+ 的額外選項 (extra options)

+validates_with+ 有 +:if+ 、+:unless+ 、+:on+ 這三個選項可用，這一點，就跟其他驗證方式一樣。如果有傳入其他選項，則會以 +options+ 的方式，送到 validator 類別去：

<ruby>
class Person < ActiveRecord::Base
  validates_with GoodnessValidator, :fields => [:first_name, :last_name]
end

class GoodnessValidator < ActiveRecord::Validator
  def validate
    if options[:fields].any?{|field| record.send(field) == "Evil" }
      record.errors[:base] << "This person is evil"
    end
  end
end
</ruby>

h4. +validates_each+ 用區塊進行自訂的驗證

按照區塊 (block) 裡的程式碼，對屬性 (attributes) 做驗證。這個工具，沒有定義任何驗證功能，您要自己用區塊來撰寫驗證，然後，每一個傳給 +validates_each+ 的屬性，都會根據您的區塊內容來做測試。下面示範，希望 names 跟 surnames 不是小寫開頭：

<ruby>
class Person < ActiveRecord::Base
  validates_each :name, :surname do |model, attr, value|
    model.errors.add(attr, 'must start with upper case') if value =~ /\A[a-z]/
  end
end
</ruby>

區塊接收了三樣東西：model 、屬性名稱、屬性的值。在區塊內，可以做任何您想做的驗證。要是驗證失敗，可以在 model 裡加入錯誤訊息，讓它變成無效的 (invalid) 。

h3. 共通的驗證選項 (Common Validation Options)

有些共通的選項 (options) ，所有的驗證輔助工具都能用，下面介紹除了 +:if+ 跟 +:unless+ 之外的共通選項。至於 +:if+ 跟 +:unless+ 會另外在 "條件式驗證 (Conditional Validation)":#conditional-validation 的部份討論。

h4. +:allow_nil+ 允許 nil 值

+:allow_nil+ 選項，在被驗證的值是 +nil+ 的時候，會略過驗證。在 +validates_presence_of+ 工具裡面，使用 +:allow_nil+ 選項的話，就可以允許 +nil+ 值，不過，其他任何的 +blank?+ 值還是一樣會被拒絕 (rejected) 。

<ruby>
class Coffee < ActiveRecord::Base
  validates_inclusion_of :size, :in => %w(small medium large),
    :message => "%{value} is not a valid size", :allow_nil => true
end
</ruby>

h4. +:allow_blank+ 允許 blank 值

+:allow_blank+ 有點類似 +:allow_nil+ ，但允許的範圍更廣。 +:allow_blank+ 會在屬性值是 +blank?+ 的時候，也讓驗證通過，像是 +nil+ 或是空字串 (empty string) 之類的。

<ruby>
class Topic < ActiveRecord::Base
  validates_length_of :title, :is => 5, :allow_blank => true
end

Topic.create("title" => "").valid? # => true
Topic.create("title" => nil).valid? # => true
</ruby>

h4. +:message+ 自訂錯誤訊息

+:message+ 選項用來自訂訊息，此訊息會在驗證失敗的時候，加到 +errors+ 集合 (collection) 裡面。沒設定此選項時， Active Record 會採用驗證輔助工具 (validation helpers) 原本內建的錯誤訊息。

h4. +:on+ 在特定的時候進行驗證

+:on+ 選項指定驗證該在何時發生。內建的驗證輔助工具，預設的行為是在儲存的時候，包括新增一筆記錄、以及更新記錄 (record) 時，都會執行驗證。您可以用 +:on => :create+ 指定只要在新增的時候驗證就好，或者，用 +:on => :update+ 設定只要在更新的時候驗證。

<ruby>
class Person < ActiveRecord::Base
  # 在更新 email 資料的時候，輸入跟先前一樣的 email 值，是可以的
  validates_uniqueness_of :email, :on => :create

  # 在新增年齡資料的時候，輸入不是數字 (non-numerical) 的值，是可以的
  validates_numericality_of :age, :on => :update

  # 預設的狀況（新增、更新，兩種狀況都驗證）
  validates_presence_of :name, :on => :save
end
</ruby>

h3. 條件式驗證 (Conditional Validation)

有時候，需要在滿足某些 ???先決條件？陳述？ (predicate) 的狀況下，才對物件做驗證。此時，就要用到 +:if+ 跟 +:unless+ 選項，選項內容可以是 ???符號/代號 (symbol) 、字串 (string) 、或 +Proc+ 。 +:if+ 選項用來指定驗證何時 *應該* 發生，而 +:unless+ 選項則指定驗證何時 *不應該* 發生。

h4. 在 +:if+ 和 +:unless+ 中使用 ???符號/代號 (Symbol)

條件式驗證時，常常要在驗證前，先呼叫某個方法，來判斷驗證條件是否成立。這個方法的名稱，可以當作 ???符號/代號 (symbol) ，以便放入 (associate) +:if+ 跟 +:unless+ 選項中。這是最常見的一種用法。

<ruby>
class Order < ActiveRecord::Base
  validates_presence_of :card_number, :if => :paid_with_card?

  def paid_with_card?
    payment_type == "card"
  end
end
</ruby>

h4. 在 +:if+ 和 +:unless+ 中使用字串 (String)

把一段有效的 Ruby 程式碼，以字串的形式，放在條件式中，如此，它就會被丟去給 +eval+ 求值。這個方法，只有適合在字串條件式很短的時候使用。

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :surname, :if => "name.nil?"
end
</ruby>

h4. 在 +:if+ 和 +:unless+ 中使用 Proc ???<--這啥

最後一種條件式驗證，是呼叫 +Proc+ 物件來放入 (associate) +:if+ 和 +:unless+ 。使用 +Proc+ 物件，就可以直接撰寫條件式 (inline condition) ，而不需要另外寫一個方法 (separate method) 。這種作法對僅僅一行的程式碼 (one-liners) 來說，再適合不過了。

<ruby>
class Account < ActiveRecord::Base
  validates_confirmation_of :password,
    :unless => Proc.new { |a| a.password.blank? }
end
</ruby>

h3. 撰寫自訂的驗證方法 (Creating Custom Validation Methods)

內建的驗證輔助工具不夠用的時候，您可以自己撰寫驗證方法。

撰寫驗證方法很簡單：撰寫新的方法，在方法中確認 models 的狀態 (state) ，當 model 無效 (invalid) 時，在 +errors+ 集合中加入錯誤訊息。然後，用 +validate+ 、 +validate_on_create+ 或 +validate_on_update+ 等類別方法 (class methods) ，將自訂方法的名稱，以符號/代號 (symbols) 的形式傳入，如此，便能註冊 (register) 您自訂的驗證方法了。

每個類別方法 (class method) 中，都可以傳入多個符號/代號 (symbol) ，與代號相對應的驗證方法，就會按照這個註冊順序，逐一的執行。

<ruby>
class Invoice < ActiveRecord::Base
  validate :expiration_date_cannot_be_in_the_past,
    :discount_cannot_be_greater_than_total_value

  def expiration_date_cannot_be_in_the_past
    errors.add(:expiration_date, "can't be in the past") if
      !expiration_date.blank? and expiration_date < Date.today
  end

  def discount_cannot_be_greater_than_total_value
    errors.add(:discount, "can't be greater than total value") if
      discount > total_value
  end
end
</ruby>

您還可以更進一步，撰寫自訂的驗證輔助工具，然後在幾個不同的 model 之間重複使用。例如，某個管理問卷調查的應用程式，需要表達出一個欄位 (field) 對應到一整組選項的狀況：

<ruby>
ActiveRecord::Base.class_eval do
  def self.validates_as_choice(attr_name, n, options={})
    validates_inclusion_of attr_name, {:in => 1..n}.merge(options)
  end
end
</ruby>

像這樣，打開 +ActiveRecord::Base+ ，在裡面定義一個類別方法就可以了。通常這段程式碼，會放在 +config/initializers+ 裡面。這個驗證輔助工具，使用的方式就像這樣：

<ruby>
class Movie < ActiveRecord::Base
  validates_as_choice :rating, 5
end
</ruby>

h3. 處理驗證錯誤 (Working with Validation Errors)

除了前面提的 +valid?+ 和 +invalid?+ 方法之外， Rails 還提供許多其他方法，來處理 +errors+ 集合，或者查詢物件的有效性。

下面只列出最常用的方法，至於完整的方法清單，請參考 +ActiveRecord::Errors+ 的文件。

h4(#working_with_validation_errors-errors). +errors+ 列出物件的錯誤訊息

把該物件的所有錯誤訊息，回傳為一個有序雜湊 (OrderedHash) 。雜湊的鍵 (key) 是屬性的名稱 (attribute name) ，值 (value) 則是一個陣列，陣列由字串所組成，這些字串，即是該屬性的所有錯誤訊息。

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name
  validates_length_of :name, :minimum => 3
end

person = Person.new
person.valid? # => false
person.errors
 # => {:name => ["can't be blank", "is too short (minimum is 3 characters)"]}

person = Person.new(:name => "John Doe")
person.valid? # => true
person.errors # => []
</ruby>

h4(#working_with_validation_errors-errors-2). +errors[]+ 列出屬性的錯誤訊息

+errors[]+ 的用途是查看某個屬性的錯誤訊息。它會傳回陣列，這個陣列是由字串組成的，每個字串就是一筆錯誤訊息。如果這個屬性並沒有任何的錯誤訊息，則會傳回一個空的陣列。

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name
  validates_length_of :name, :minimum => 3
end

person = Person.new(:name => "John Doe")
person.valid? # => true
person.errors[:name] # => []

person = Person.new(:name => "JD")
person.valid? # => false
person.errors[:name] # => ["is too short (minimum is 3 characters)"]

person = Person.new
person.valid? # => false
person.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]
</ruby>

h4. +errors.add+ 手動加入錯誤訊息

+add+ 方法可以針對某個屬性，用手動的方式，加入錯誤訊息。這些錯誤訊息，在使用者眼中大概會看到的樣子，可以用 +errors.full_messages+ 或 +errors.to_a+ 這兩種方法來預覽，它們會把屬性的名稱，開頭變大寫後，顯示在錯誤訊息前面。 +add+ 方法接收兩樣東西：一是屬性名稱，二是您想手動附上的錯誤訊息。

<ruby>
class Person < ActiveRecord::Base
  def a_method_used_for_validation_purposes
    errors.add(:name, "cannot contain the characters !@#%*()_-+=")
  end
end

person = Person.create(:name => "!@#")

person.errors[:name]
 # => ["cannot contain the characters !@#%*()_-+="]

person.errors.full_messages
 # => ["Name cannot contain the characters !@#%*()_-+="]
</ruby>

除了 +add+ 之外的另一個作法，是用 +[]=+ 這個 ??? 設定式 (setter)

<ruby>
  class Person < ActiveRecord::Base
    def a_method_used_for_validation_purposes
      errors[:name] = "cannot contain the characters !@#%*()_-+="
    end
  end

  person = Person.create(:name => "!@#")

  person.errors[:name]
   # => ["cannot contain the characters !@#%*()_-+="]

  person.errors.to_a
   # => ["Name cannot contain the characters !@#%*()_-+="]
</ruby>

h4. +errors[:base]+ 關連到物件整體的錯誤訊息

通常，錯誤訊息是關連到物件裡的某一個屬性，不過，您也可以加入跟整個物件相關連的錯誤訊息。有時候，我們不需詳細列出物件裡的各個屬性的值，只要表示出這個物件沒有通過驗證就好，此時，就可以用 +errors[:base]+ ，它是一個陣列，只要在陣列中加入字串，這字串就可以拿來當物件的錯誤訊息了。

<ruby>
class Person < ActiveRecord::Base
  def a_method_used_for_validation_purposes
    errors[:base] << "This person is invalid because ..."
  end
end
</ruby>

h4. +errors.clear+ 清空錯誤訊息

+clear+ 方法用來清空 +errors+ 集合裡的所有錯誤訊息。清空錯誤訊息，並不會讓原本無效的物件變成有效的物件，因為，雖然錯誤訊息清空了，但下次呼叫 +valid?+ 方法時，或者想把物件寫入資料庫時，都會再一次的觸發驗證，一旦驗證失敗， +errors+ 集合就會再度的被填滿。

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name
  validates_length_of :name, :minimum => 3
end

person = Person.new
person.valid? # => false
person.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]

person.errors.clear
person.errors.empty? # => true

p.save # => false

p.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]
</ruby>

h4. +errors.size+ 物件的錯誤訊息總數

+size+ 方法會傳回這個物件的所有錯誤訊息的總數。

<ruby>
class Person < ActiveRecord::Base
  validates_presence_of :name
  validates_length_of   :name, :minimum => 3
  validates_presence_of :email
end

person = Person.new
person.valid? # => false
person.errors.size # => 3

person = Person.new(:name => "Andrea", :email => "andrea@example.com")
person.valid? # => true
person.errors.size # => 0
</ruby>

h3. 在視圖中秀出驗證錯誤 (Displaying Validation Errors in the View)

Rails 內建了輔助工具 (helpers) ，可以在視圖模板 (view templates) 中，顯示 models 的錯誤訊息 (error messages) 。

h4. +error_messages+ 以及 +error_messages_for+ 在視圖中呈現錯誤訊息

用 +form_for+ 輔助工具新增表格的時候，可以在 ??? 表格產生器 (form builder) 裡面，用 +error_messages+ 方法，把目前的 model 實體 (instance) 的全部驗證訊息，演算呈現 (render) 出來。

<ruby>
class Product < ActiveRecord::Base
  validates_presence_of :description, :value
  validates_numericality_of :value, :allow_nil => true
end
</ruby>

<erb>
<%= form_for(@product) do |f| %>
  <%= f.error_messages %>
  <p>
    <%= f.label :description %><br />
    <%= f.text_field :description %>
  </p>
  <p>
    <%= f.label :value %><br />
    <%= f.text_field :value %>
  </p>
  <p>
    <%= f.submit "Create" %>
  </p>
<% end %>
</erb>

送出 (submit) 上述的表單時，如果表單內有空白欄位 (empty fields) ，就會得到如下圖般的回應。預設狀況下，這個回應的頁面是沒有套用樣式 (styles) 的。

!images/error_messages.png(Error messages)!

對於指定給視圖模板 (view template) 的 model ，要顯示它的錯誤訊息的話，也可以用 +error_messages_for+ 輔助工具來做。它跟上面的範例很像，最後結果也是一模一樣：

<erb>
<%= error_messages_for :product %>
</erb>

呈現錯誤訊息的文字，格式是「大寫開頭的屬性名稱 + 錯誤訊息」。

+form.error_messages+ 跟 +error_messages_for+ 這兩個輔助工具，都可以針對包裹著訊息文字的 +div+ 元素 (element) ，接收一些自訂的選項，用來自訂標題文字 (header text) 、標題文字下方的訊息、以及標題元素的標籤 (tag) 。

<erb>
<%= f.error_messages :header_message => "Invalid product!",
  :message => "You'll need to fix the following fields:",
  :header_tag => :h3 %>
</erb>

會產生以下內容：

!images/customized_error_messages.png(Customized error messages)!

如果對任一個選項傳入 +nil+ 值，它會 ??? 從原本所在的 +div+ 區段 (section) 中，跳脫出來。 get rid of the respective section of the +div+.

h4. 自訂錯誤訊息的串接樣式表 (CSS)

用來自訂錯誤訊息樣式 (styles) 的選擇器 (selectors) 包括：

* +.field_with_errors+ - 顯示錯誤訊息的表格欄位 (form fields) 與標籤 (labels) 的樣式 (style) 。
* +#errorExplanation+ - 包覆著錯誤訊息的 +div+ 元素的樣式。
* +#errorExplanation h2+ - +div+ 元素之內的標題 (header) 的樣式。
* +#errorExplanation p+ - +div+ 元素之內，在標題 (header) 下方緊接著出現的段落文字 (paragraph) 的樣式。
* +#errorExplanation ul li+ - 列出各個錯誤訊息的項目清單 (list items) 的樣式。

??? Rails 內建的範例的鷹架 (scaffolding) 會產生出 +public/stylesheets/scaffold.css+ 樣式表 (CSS) ，這個樣式表定義了如上圖這般的紅色系樣式。

要修改樣式表 (CSS) 裡面所設定的 class 跟 id 的名稱，可以用 +:class+ 跟 +:id+ 兩個選項，這二個選項在 +form_for+ 和 +error_messages_for+ 兩種輔助工具中，都是可以用的。

h4. 自訂錯誤訊息的 HTML

按照預設，錯誤訊息的表單欄位 (form fields) 是包在一個 +div+ 元素裡面，而這個 +div+ 元素的 CSS class 是 +field_with_errors+ 。不過這個樣式設定，是可以覆寫 (override) 過去的。

要如何處理錯誤訊息的表單欄位，是定義在 +ActionView::Base.field_error_proc+ 裡面的，它是一個 +Proc+ ，可以接收兩個參數 (parameters) ：

* 帶有 HTML 標籤 (tag) 的字串 (string) 。
* +ActionView::Helpers::InstanceTag+ 類別的實體 (instance) 。

這裡簡單示範，把 Rails 的行為改成「總是把錯誤訊息顯示在表單欄位的前面」，錯誤訊息用 +span+ 元素包起來，元素的 CSS class 是 +validation-error+ 。由於 +input+ 元素外層沒有 +div+ 元素包著，所以文字欄位的周圍就不會有那個紅色邊框了。不管您想要什麼樣式，都可以用 +validation-error+ 這個 CSS class 來做設定。

<ruby>
ActionView::Base.field_error_proc = Proc.new do |html_tag, instance|
  if instance.error_message.kind_of?(Array)
    %(#{html_tag}<span class="validation-error">&nbsp;
      #{instance.error_message.join(',')}</span>)
  else
    %(#{html_tag}<span class="validation-error">&nbsp;
      #{instance.error_message}</span>)
  end
end
</ruby>

這段程式碼會產生如下圖的結果：

!images/validation_error_messages.png(Validation error messages)!

h3. 回呼的概觀 (Callbacks Overview)

回呼 (callbacks) 是在物件生命週期裡的特定時刻，所被呼叫的方法。有了它，就可以在 Active Record 物件新增、儲存、更新、刪除、驗證、或者從資料庫載入時，執行我們自己撰寫的程式碼。

h4. 註冊回呼 (Callback Registration)

要使用回呼 (callback) 之前，必須先註冊 (register) 它。要註冊回呼，可以先將這些回呼實作成一般的方法 (methods) ，然後，用一個 ??? 巨集式的類別方法 (macro-style class method) ，將它們註冊成回呼。

<ruby>
class User < ActiveRecord::Base
  validates_presence_of :login, :email

  before_validation :ensure_login_has_a_value

  protected
  def ensure_login_has_a_value
    if login.nil?
      self.login = email unless email.blank?
    end
  end
end
</ruby>

??? 巨集式的類別方法 macro-style class methods 也可以接收程式區塊 (block) ，如果區塊內的程式碼很短，短到可以一行之內寫完，那麼就可以考慮用區塊的方式來註冊回呼。

<ruby>
class User < ActiveRecord::Base
  validates_presence_of :login, :email

  before_create {|user| user.name = user.login.capitalize
	if user.name.blank?}
end
</ruby>

預設的狀況下，回呼方法 (callback methods) 是 public 的。但比較好的作法，是將它宣告為 protected 或 private ，因為，這樣做的話，在 model 之外的地方，就無法呼叫這些方法，也就不會侵犯到物件封裝 (object encapsulation) 的原則了。

h3. 可以用哪些回呼方法 (Available Callbacks)

這裡列出 Active Record 的回呼方法 (callbacks) ，列出的順序，即是這些方法在建立、更新、銷毀等對應的操作 (operations) 裡面，被呼叫的順序。

h4. 建立物件 (Creating an Object)

* +before_validation+
* +after_validation+
* +before_save+
* +after_save+
* +before_create+
* +around_create+
* +after_create+

h4. 更新物件 (Updating an Object)

* +before_validation+
* +after_validation+
* +before_save+
* +after_save+
* +before_update+
* +around_update+
* +after_update+

h4. 銷毀物件 (Destroying an Object)

* +before_destroy+
* +after_destroy+
* +around_destroy+

WARNING. +after_save+ 在建立、更新時，都可以運作，但是，不管 ??? 巨集請求 (macro calls) 執行的順序如何，+after_save+ 永遠是在 +after_create+ 跟 +after_update+ 的 _之後_ 才會運作。

h4. +after_initialize+ 與 +after_find+

Active Record 物件初始化的時候，不管是直接用 +new+ 初始化，或是從資料庫中載入一筆記錄 (record) 來初始化，都會呼叫 +after_initialize+ 這個回呼 (callback) 。使用回呼的好處是，可以避免直接覆蓋 (override) 掉 Active Record 原本的 +initialize+ 方法。

Active Record 每一次從資料庫中載入一筆記錄 (record) 時，除了 +after_initialize+ 之外，還會多呼叫 +after_find+ 這個回呼 (callback) 。如果 +after_find+ 和 +after_initialize+ 兩者都有定義的話，則會先呼叫 +after_find+ 。

+after_initialize+ 和 +after_find+ 跟其他的回呼 (callbacks) 有點不一樣。它們沒有相對的 +before_*+ 回呼，而它們註冊的方式，只有一種，就是將它們定義為一般的方法 (regular methods) 。如果，用巨集式的類別方法 (macro-style class methods) 來註冊 +after_initialize+ 或 +after_find+ ，那它們會直接的被忽略掉。設計這樣的行為，是為了效能 (performance) 上的考量，因為，在資料庫中每找到一筆記錄，都會呼叫 +after_initialize+ 和 +after_find+ ，而明顯的拖慢查詢的速度。

<ruby>
class User < ActiveRecord::Base
  def after_initialize
    puts "You have initialized an object!"
  end

  def after_find
    puts "You have found an object!"
  end
end

>> User.new
You have initialized an object!
=> #<User id: nil>

>> User.first
You have found an object!
You have initialized an object!
=> #<User id: 1>
</ruby>

h3. 執行回呼 (Running Callbacks)

以下這些方法，會觸發 (trigger) 回呼：

* +create+
* +create!+
* +decrement!+
* +destroy+
* +destroy_all+
* +increment!+
* +save+
* +save!+
* +save(false)+
* +toggle!+
* +update+
* +update_attribute+
* +update_attributes+
* +update_attributes!+
* +valid?+

另外，以下這些 ??? 查找器方法 (finder methods) ，會觸發 +after_find+ 這個回呼：

* +all+
* +first+
* +find+
* +find_all_by_<em>attribute</em>+
* +find_by_<em>attribute</em>+
* +find_by_<em>attribute</em>!+
* +last+

而 +after_initialize+ 回呼被觸發的時機，則是在該類別 (class) 每次初始化 (initialized) 一個新物件的時候。

h3. 略過回呼 (Skipping Callbacks)

回呼 (callbacks) 是可以略過的，這一點就跟驗證 (validations) 一樣。不過，用這些略過回呼的方法時，必須很小心，因為可能會有一些重要的商業規則 (business rules) 跟應用程式邏輯 (application logic) 是放在回呼裡面的，如果不清楚所造成的影響，就略過回呼的話，可能會導致無效資料 (invalid data) 的產生。

* +decrement+
* +decrement_counter+
* +delete+
* +delete_all+
* +find_by_sql+
* +increment+
* +increment_counter+
* +toggle+
* +update_all+
* +update_counters+

h3. 中止執行鏈 (Halting Execution)

為 model 註冊新的回呼 (callbacks) 時，這些回呼，會加入佇列 (queued) 等待執行。佇列 (queue) 裡面包含：該 model 全部的驗證 (validations) 、要註冊的回呼、以及要執行的資料庫操作 (database operation) 。

這一整個回呼鏈 (callback chain) ，是包裹在交易功能 (transaction) 裡面的。過程中，如果有任何  <em>before</em> 回呼方法傳回了 +false+ ，或者是丟出了例外 (raises an exception) ，整個執行鏈 (execution chain) 就會中途停止，且必須訴諸 (issued) 滾回 (ROLLBACK) 。至於 <em>after</em> 回呼方法，則是只有在丟出例外 (raising an exception) 的時候，才會導致執行鏈的中止。

WARNING. 一旦丟出任何的例外 (exception) ，若有某段程式碼，預期要執行 +save+ 等 ??? 不該出現例外的動作的話，就有可能因此而被打斷。 Raising an arbitrary exception may break code that expects +save+ and friends not to fail like that. 進行滾回 (rollback) 的時候， +ActiveRecord::Rollback+ 這個例外，會精確的告訴 Active Record 有個滾回正在進行。這個例外，會由 ??? 內部捕捉 (internally captured) ，但不會被 ??? 再次丟出 (reraised) 。

h3. 關連性回呼 (Relational Callbacks)

回呼 (callbacks) 能夠針對 model 和其他 model 間的關連 (relationships) 運作，甚至可以用回呼來定義 model 間的關連。如果有個使用者，同時有許多篇發表的文章，而我們希望使用者帳號銷毀時，文章也跟著銷毀。於是，我們在 +User+ model 中，針對 +User+ model 跟 +Post+ model 之間的關連，加入 +after_destroy+ 回呼。範例如下：

<ruby>
class User < ActiveRecord::Base
  has_many :posts, :dependent => :destroy
end

class Post < ActiveRecord::Base
  after_destroy :log_destroy_action

  def log_destroy_action
    puts 'Post destroyed'
  end
end

>> user = User.first
=> #<User id: 1>
>> user.posts.create!
=> #<Post id: 1, user_id: 1>
>> user.destroy
Post destroyed
=> #<User id: 1>
</ruby>

h3. 條件式回呼 (Conditional Callbacks)

回呼 (callbacks) 也可以寫成條件式的 (conditional) ，在某個先決條件成立時，才呼叫它們，撰寫條件式回呼的方式，就像本文前幾節在驗證 (validations) 中所做的一樣。要做條件判斷，可以用 +:if+ 跟 +:unless+ 選項 (options) ，這些選項可以接收符號/代號 (symbol) 、字串 (string) 或是 +Proc+ 。定義條件時，若是在某狀況下 *必須* 呼叫回呼，可以用 +:if+ 選項；相反地，在某狀況下 *必須不* 呼叫回呼，則是用 +:unless+ 選項。

h4. 在 +:if+ 與 +:unless+ 中使用符號/代號 (Symbol)

+:if+ 與 +:unless+ 可以用符號/代號 (symbol) 來放入其中 (associate) ，這個符號 (symbol) ，是對應到回呼 (callback) 執行前一刻所呼叫的方法 (method) 的名稱。使用 +:if+ 選項 (option) 時，若這個方法傳回假值 (false) ，回呼就不會執行；相反地，使用 +:unless+ 選項的話，若這個方法傳回真值，回呼就不會執行。以上是最常用到的選項，用這種格式 (form) 註冊回呼的話，還可以針對回呼是否執行的判斷，註冊數個不同的方法。

<ruby>
class Order < ActiveRecord::Base
  before_save :normalize_card_number, :if => :paid_with_card?
end
</ruby>

h4. 在 +:if+ 與 +:unless+ 中使用字串 (String)

條件式裡面也可以放字串 (string) ，這個字串會用 +eval+ 來求值 (evaluated)，字串內容必須是一段有效的 Ruby 程式碼。只有真的很簡短的條件式，才適合用字串形式放在選項 (options) 裡面。

<ruby>
class Order < ActiveRecord::Base
  before_save :normalize_card_number, :if => "paid_with_card?"
end
</ruby>

h4. 在 +:if+ 與 +:unless+ 中使用 ??? 程式碼物件 (Proc)

最後， +:if+ 跟 +:unless+ 還可以放入 +Proc+ 物件。這種作法，尤其適合用來撰寫簡短的驗證方法，通常是一行以內的 (one-liners) 。

<ruby>
class Order < ActiveRecord::Base
  before_save :normalize_card_number,
    :if => Proc.new { |order| order.paid_with_card? }
end
</ruby>

h4. 回呼的多重條件 (Multiple Conditions for Callbacks)

撰寫條件式回呼 (conditional callbacks) 時，可以在同一個回呼宣告 (callback declaration) 裡面，同時混用 +:if+ 跟 +:unless+ 。

<ruby>
class Comment < ActiveRecord::Base
  after_create :send_email_to_author, :if => :author_wants_emails?,
    :unless => Proc.new { |comment| comment.post.ignore_comments? }
end
</ruby>

h3. 回呼類別 (Callback Classes)

有時候，某 model 的回呼方法 (callback methods) ，在其他的 model 中也能重複使用。 Active Record 讓我們能夠建立回呼類別 (callback classes) ，來封裝 (encapsulate) 這些回呼方法，如此一來，就可以很容易的重複利用它們。

底下範例，針對 +PictureFile+ model ，建立了一個內含 +after_destroy+ 回呼的類別 (class) 。

<ruby>
class PictureFileCallbacks
  def after_destroy(picture_file)
    File.delete(picture_file.filepath)
      if File.exists?(picture_file.filepath)
  end
end
</ruby>

在類別內部宣告 (declare) 回呼方法 (callback methods) 的時候，回呼方法會接收 model 物件做為參數 (parameter) ，用法如下：

<ruby>
class PictureFile < ActiveRecord::Base
  after_destroy PictureFileCallbacks.new
end
</ruby>

由於將回呼 (callback) 宣告為實體方法 (instance method) ，所以使用回呼時，必須先實體化 (instantiate) 新的 +PictureFileCallbacks+ 物件。有些時候，把回呼宣告為類別方法 (class method) 會比較合理些。

<ruby>
class PictureFileCallbacks
  def self.after_destroy(picture_file)
    File.delete(picture_file.filepath)
      if File.exists?(picture_file.filepath)
  end
end
</ruby>

這種宣告方式，就不需要把 +PictureFileCallbacks+ 物件實體化 (instantiate) 了。

<ruby>
class PictureFile < ActiveRecord::Base
  after_destroy PictureFileCallbacks
end
</ruby>

回呼類別 (callback classes) 裡面，可以宣告的回呼在數量上並沒有限制，要宣告多少個都可以。

h3. 觀測器 (Observers)

觀測器 (observers) 跟回呼 (callbacks) 很像，但是有個重大的差別，差別在於，回呼的程式碼會污染 (pollute) model ，而這些程式碼，往往與 model 本身的用途，並沒有直接的關係；但是，觀測器 (observers) 卻可以在 model 的外部，以不會污染到 model 的方式，做到跟回呼一樣的功能。像是 +User+ model 裡面，其實不該有送出註冊確認信 (registration confirmation emails) 的程式碼，這種時候，回呼內的程式碼跟 model 本身沒有直接關係，就可以考慮用觀測器 (observer) 來代替回呼 (callbacks) 。

h4. 建立觀測器 (Creating Observers)

假設有個 +User+ model ，希望每次它新增使用者的時候，系統都送出一封確認 email 。由於寄信並不是 +User+ model 存在的目的，所以，我們可以用觀測器 (observer) 來加入這個功能。

<shell>
rails generate observer User
</shell>

<ruby>
class UserObserver < ActiveRecord::Observer
  def after_create(model)
    # code to send confirmation email...
  end
end
</ruby>

觀測器的方法 (methods) ，是將它所觀測的 model 接收為一個參數 (parameter) ，這一點，就跟回呼類別 (callback classes) 是一樣的。

h4. 註冊觀測器 (Registering Observers)

依照慣例，觀測器是放在 +app/models+ 目錄裡面，並且註冊在應用程式的 +config/environment.rb+ 檔案中。像是上面提到的 +UserObserver+ ，就會儲存成 +app/models/user_observer.rb+ ，然後在 +config/environment.rb+ 中註冊，像這樣子：

<ruby>
# Activate observers that should always be running
config.active_record.observers = :user_observer
</ruby>

相較於 +config/environment.rb+ ，+config/environments+ 內的設定，優先權 (precedence) 是比較高的。因此，如果某個觀測器 (observer) 並不需要在所有的環境 (environments) 內執行，那麼可以單純的在某個特定的環境 (environment) 內註冊就好。

h4. 共享觀測器 (Sharing Observers)

預設之下， Rails 會單純的把觀測器 (observer) 的名稱，除掉 "Observer" 這幾個字後，去尋找相同名稱的 model ，做為觀測的對象。不過，觀測器 (observer) 其實可以對上多個 model ，而我們可以手動的指定這些 model 。

<ruby>
class MailerObserver < ActiveRecord::Observer
  observe :registration, :user

  def after_create(model)
    # code to send confirmation email...
  end
end
</ruby>

這個範例中，在 +Registration+ 或 +User+ 新建立的時候，都會呼叫 +after_create+ 方法 (method) 。這個新出現的 +MailerObserver+ 也需要在 +config/environment.rb+ 中註冊，才會產生作用。

<ruby>
# Activate observers that should always be running
config.active_record.observers = :mailer_observer
</ruby>

h3. 文件修改記錄 (Changelog)

"Lighthouse ticket":http://rails.lighthouseapp.com/projects/16213/tickets/26-active-record-validations-and-callbacks

* July 20, 2010: Fixed typos and rephrased some paragraphs for clarity. "Jaime Iniesta":http://jaimeiniesta.com
* May 24, 2010: Fixed document to validate XHTML 1.0 Strict. "Jaime Iniesta":http://jaimeiniesta.com
* May 15, 2010: Validation Errors section updated by "Emili Parreño":http://www.eparreno.com
* March 7, 2009: Callbacks revision by Trevor Turk
* February 10, 2009: Observers revision by Trevor Turk
* February 5, 2009: Initial revision by Trevor Turk
* January 9, 2009: Initial version by "Cássio Marques":credits.html#cmarques

h3. 關於譯者

* 譯者：藍一婷 (a.k.a. "ETBlue":http://etblue.blogspot.com/) 
* 編輯：張文鈿 (a.k.a. "ihower":http://ihower.tw/blog/)
* 意見回饋：高見龍 (a.k.a. "Eddie Kao":http://blog.eddie.com.tw/)
* 翻譯的原始碼位於 "http://github.com/ihower/docrails":http://github.com/ihower/docrails

h3. 翻譯詞彙

本文翻譯自 "http://edgeguides.rubyonrails.org/active_record_validations_callbacks.html":http://edgeguides.rubyonrails.org/active_record_validations_callbacks.html 。英文與繁體中文的對照詞彙，請見 "rails-guide-glossary-list-zh_tw":https://spreadsheets.google.com/ccc?key=0AkNsS2a-Qx8ZdDJzTUlNeVlvRy1BYnZDUnRjZUpWWGc&hl=en
部份翻譯詞彙參考自「"Ruby Programming－向Ruby之父學程式設計":http://anobii.com/books/Ruby_Programming/9789575279776/018bca897e4b3aafa8/」以及「"松本行弘的程式世界：成為一流程式設計師的14種思考術":http://anobii.com/books/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BC%8F%E4%B8%96%E7%95%8C/9789862013571/017262b33d6647d8f3/」二書，皆為博碩出版。
