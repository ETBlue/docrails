h2. Rails 第一次上手

這份文件涵蓋如何上手開始使用 Ruby on Rails。閱讀之後您應該可以熟悉：

* 安裝 Rails，建立一個新的 Rails 應用程式，並連結到資料庫。
* Rails 的架構
* MVC (Model, View Controller) 的基本原理以及 RESTful 設計
* 如何快速產生可以運作的 Rails 應用程式

endprologue.

WARNING. 這份文件基於 Rails 3.0。某些程式碼將無法運行於舊版 Rails。

h3. 前提

這份指南的目標是幫助初學者從零開始學習 Rails 應用程式，不需要有任何 Rails 經驗。不過要能夠讀的懂這份文件，還是需要一些前提條件：

* "Ruby 程式語言":http://www.ruby-lang.org/en/downloads 版本 1.8.7 或 1.9.2 之後

TIP: Ruby 1.8.7 p248 和 p249 已知有 marshaling 臭虫會搞爛 Rails 3.0。而 Ruby Enterprise Edition 從 1.8.7-2010.02 之後已經修正。1.9.1 也不適用會造成 segfaults，所以如果你要用 1.9.x 請從 1.9.2 開始。

* "RubyGems":http://rubyforge.org/frs/?group_id=126 Ruby 的套件管理系統
* 安裝好的 "SQLite3 資料庫":http://www.sqlite.org

Rails 是一套跑在 Ruby 上的 Web 框架。如果您對 Ruby 一無所知就一頭栽進 Rails，您的學習曲線會非常陡峭。以下是一些網路上的免費 Ruby 學習資源：

* "Mr. Neighborly's Humble Little Ruby Book":http://www.humblelittlerubybook.com
* "Programming Ruby":http://www.ruby-doc.org/docs/ProgrammingRuby/
* "Why's (Poignant) Guide to Ruby":http://mislav.uniqpath.com/poignant-guide/

h3. 什麼是 Rails?

Rails 是一個使用 Ruby 程式語言開發的網站開發架構。它被設計成只要開發者了解它的慣例，它就可以讓網站開發變成更容易。相對其他語言和框架，Rails 讓你用更少的程式碼達成更多的功能。有經驗的 Rails 開發者也表示它讓網站開發更有趣。

Rails 是個有主見的軟體。意思是說它假定事情有"最佳解"，而且它也被設計成鼓勵那麼做 - 以及不鼓勵其他作法。如果你學會所謂的 "The Rails Way" 的話，你的生產力非常可能將獲得極大的增長。但如果你用其他語言的習慣或模式來使用 Rails，你可能會有不快樂的經驗。

Rails 的哲學包括以下的指導原則：

* DRY - "不要重複自己(Don't Repeat Yourself)" - 一直撰寫出重複的程式碼是件壞事
* 慣例勝於設計(Convention Over Configuration) - Rails 會假設什麼是你要做的事情跟如何去做，而不是要求你設定每一個細節到設定檔中。
* REST 是 Web 應用程式的最佳模式 - 使用 resources 和標準的 HTTP 動詞來組織你的應用程式是最快的方式

h4. MVC 架構

Rails 的核心是 Model, View 和 Controller 的架構，通常稱作 MVC。MVC 的好處包括：

* 從使用者介面中把商業邏輯隔離出來
* 更容易使程式保持 DRY
* 容易維護，讓不同的程式碼乾淨地放在屬於它的地方

h5. Models

Model 代表了應用程式的資訊(資料)和如何操作資料的邏輯。在 Rails 中，Models 主要的功能是負責操作資料庫資料表的邏輯。在大多數的情況，一個資料表就對應了一個 Model。你的應用程式商業邏輯也將放在 Models 中。

h5. Views

Views 代表了你的應用程式的使用者介面。在 Rails 中，Views 通常就是有個內嵌 Ruby 程式(可以操作如何顯示資料)的 HTML 檔案。Views 負責提供資料給瀏覽器或其他發 HTTP 請求的軟體。

h5. Controllers

Controllers 是 Models 和 Views 之間的黏著膠水。在 Rails 中，Controllers 負責處理從瀏覽器進來的 HTTP 請求，對 Models 詢問資料，然後將資料傳進 Views 中顯示出來。

h4. Rails 的元件

Rails 包括許多個別的元件。

* Action Pack
  ** Action Controller
  ** Action Dispatch
  ** Action View
* Action Mailer
* Active Model
* Active Record
* Active Resource
* Active Support
* Railties

h5. Action Pack

Action Pack 是一個 Gem 包括 Action Controller、Action View 和 Action Dispatch。也就是 "MVC" 中的 "VC" 部分。

h5. Action Controller

Action Controller 是 Rails 應用程式中，管理 Controllers 的元件。Action Controller 框架處理給 Rails 的 HTTP 請求，萃取出參數，然後分派給預期的 Action。Action Controller 還提供了 session 管理、樣板演算顯示(template rendering) 和 redirect。

h5. Action View

Action View 負責 Rails 應用程式中的 Views。它預設可以產生 HTML 或 XML 的輸出。Action View 負責樣板的演算顯示(template rendering)，包括嵌套(nesting)或局部(partial)的樣板，甚至也內建支援一些 Ajax。

h5. Action Dispatch

Action Dispatch 處理 HTTP 請求的路由，它將 HTTP 請求發派(dispatch)到它該去的地方，也許是你的應用程式或其他 Rack 應用程式。

h5. Action Mailer

Action Mailer 是一個建構 e-mail 功能的框架。你可以使用 Action Mailer 來接收處理來信，或是彈性地使用樣板來寄出純文字或複雜的 multipart 信件。

h5. Active Model

Active Model 在 Action Pack gem 和 ORM(Object Relationship Mapping) gem (例如 Active Record) 之間，定義了一組介面。 Active Model 允許 Rails 依你的需求可以置換 Active Record 成其他 ORM 框架。

h5. Active Record

Active Record 是 Rails 應用程式中的 Models 基礎。它不依存特定的資料庫系統，提供了基本的 CRUD 功能、先進的查詢能力，以及與其他 Models 關連的本事。

h5. Active Resource

Active Resource 提供了與其他商業物件和 RESTful 網路服務的連結框架。它實作了一種可以對應以 Web 為基礎的 Resources 成為本地端可以 CRUD 的物件。

h5. Active Support

Active Support 是一套用在 Rails 裡的工具函式庫，它也擴充了一些 Ruby 標準函式庫。除了被用在 Rails 核心程式中，你也可以在你的應用程式裡使用。

h5. Railties

Railties 是 Rails 的核心程式碼，用來將以上各種的框架函式庫以及 Plugin 全部組合在一起。

h4. REST

Rest 代表了 "Representational State Transfer" (表象化狀態轉變)，它也是 RESTful 架構的基礎概念。它被認為出自於 Roy Fielding 的博士論文 "Architectural Styles and the Design of Network-based Software Architectures":http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm 。當你閱讀這篇論文的時候，REST 被 Rails 濃縮成兩個主要定理：

* 使用 Resource 來當做識別資源，也就是使用 URLs 來代表 Resources
* Transferring representations of the state of that resource between system components (譯註：????)

例如，對 Rails 應用程式來說，這樣的 HTTP 請求：

<tt>DELETE /photos/17</tt>

將被解讀為指向一個 photo resource 的 ID 17，而且帶著一個動作 - 刪除這個 resource。REST 對 Web 應用程式來說是一個自然的設計風格，而 Rails 幫你將這個概念包裝實作出來，必且免於眾多繁雜 RESTful 理論及瀏覽器怪癖之苦。

如果你想知道更多關於 REST 架構風格，以下資源比起 Fielding 的論文更容易親近：

* "A Brief Introduction to REST":http://www.infoq.com/articles/rest-introduction by Stefan Tilkov
* "An Introduction to REST":http://bitworking.org/news/373/An-Introduction-to-REST (video tutorial) by Joe Gregorio
* "Representational State Transfer":http://en.wikipedia.org/wiki/Representational_State_Transfer article in Wikipedia
* "How to GET a Cup of Coffee":http://www.infoq.com/articles/webber-rest-workflow by Jim Webber, Savas Parastatidis & Ian Robinson

(譯註： "什麼是REST跟RESTful?":http://ihower.tw/blog/archives/1542 了解 REST 理論並不是在 Rails 中使用 RESTful 技術的前提，所以大可以跳過不甚理解沒關係。)

h3. 建立一個新的 Rails 專案

接下來的範例，你將建立一個叫做 <tt>blog</tt> 的 Rails 專案，非常簡單的部落格系統。在你開始建構這個應用程式之前，你需要確認你的 Rails 已經安裝妥當。

h4. 安裝 Rails

大多數的情況，最簡單的安裝方式就是透過 Rubygems：

<shell>
通常會用 root user 來執行：
$ gem install rails
</shell>

WARNING. 目前還是 Rails 3.0.0-beta 尚未正式發行 Rails 3.0，你必須執行 <tt>gem install rails --pre</tt>

TIP: 如果你使用 Windows，你可以安裝看看 "Instant Rails":http://instantrails.rubyforge.org/wiki/wiki.pl ，不過要注意它的 Rails 版本比較舊不相容。另外你也會發現 Rails 跑在 Windows 很慢。所以可能的話，我們建議你裝在 Linux 虛擬機器上跑 Rails，而不是 Windows。(譯註：建議使用 "RubyInstall":http://rubyinstaller.org/ 安裝 Ruby 1.8.7 或是用 "VirtualBox":http://www.virtualbox.org/ 跑 "Ubuntu Desktop Edition":http://www.ubuntu.com/desktop )

h4. 建立部落格應用程式

本指南的最佳學習方式就是跟著接下來的每個步驟。沒有任何程式或步驟會被省略掉，所以你可以一步步跟著。如果你需要下載完整的程式，可以從這裡下載 "Getting Started Code":http://github.com/mikel/getting-started-code 。

要開始了，首先打開一個指令列視窗(terminal)，然後看看去哪一個目錄適合放程式，接著輸入：

<shell>
$ rails new blog
</shell>

這會建立一個叫做 Blog 的 Rails 應用程式在 blog 目錄下。

TIP: 你可以透過 <tt>rails -h</tt> 的指令看到所有可用的指令

完成之後，進到這個目錄下繼續：

<shell>
$ cd blog
</shell>

無論如何，Rails 都會建立一個工作目錄叫做 <tt>blog</tt>。打開這個目錄看看它的內容。本教學的大部分工作都會發生在 <tt>app</tt> 目錄下，這裡我們簡單走訪一下各個目錄的預設功能：

|_.檔案/目錄|_.目錄|
|Gemfile| 設定你的 Rails 應用程式會使用哪些 Gems |
|README.rdoc| 你的應用程式的使用手冊。你可以用來告訴其他人你的應用程式是做什麼用的，如何使用等等。 |
|Rakefile| 載入可以被 termial 執行的任務 |
|app/| 包含了 Controllers、Models 和 Views，在接下來的教學你可以專注在這個目錄。|
|config/| 應用程式設定檔、路徑規則、資料庫設定等等 |
|config.ru| 用來啟動應用程式的 Rack 設定檔 |
|db/| 目前資料庫的 Schema 和資料庫 Migrations，我們很快就會學到什麼是 Migrations |
|doc/| 用來放你的完整文件 |
|lib/| 擴充的 Modules 檔案 (不再本指南範圍) |
|log/| 應用程式的 log 檔案 |
|public/| 唯一可以在網路上看到的目錄，這是你的圖檔、javascript、stylesheets (CSS) 和其他靜態檔案擺放的地方 |
|script/| 包括了讓你開始 Rails 專案的 script 以及其他 script |
|test/| 單元測試、fixtures 及其他測試程式，我們在 "Testing Rails Applications":testing.html 一文中會介紹 |
|tmp/| 暫時性的檔案|
|vendor/| 用來放第三方程式碼的地方。在一個傳統的 Rails 應用程式，包括了 Ruby Gems、Rails 原始碼 (如果你要裝在你的專案裡面) 和有額外功能的 |

h4. 安裝必要的 Gems

Rails 使用 "Bundler":http://www.github.com/carlhuda/bundler gem 來管理所有你應用程式會依存的 gems 到 +vendor+ 目錄。到目前為止，我們根據預設不需要特殊的 gem，我們只需要這樣做：

<shell>
用 root user 身分:
$ gem install bundler
$ bundle install
</shell>

這將檢查所有你開發 Rails 應用程式所需要的 gem 。

h4. 設定資料庫


幾乎每一個 Rails 應用程式都會跟資料庫互動。資料庫需要特定的設定檔在 +config/database.yml+。如果你打開這個檔案，你會發現預設的設定是 SQLite3。這個檔案包含三個不同的部分，對應到三個 Rails 預設環境：

* +development+ environment 開發模式，用在你的開發的時候
* +test+ environment 測試模式，用在自動測試時
* +production+ environment 正式上線模式，用在實際的上線運作環境

h5. 設定 SQLite3 資料庫

Rails 預設內建支援 "SQLite3":http://www.sqlite.org 這是一套非常輕量的非伺服器型資料庫程式。雖然繁重的上線環境可能超過 SQLite 的負擔，但是它卻非常適合開發和測試時使用。Rails 預設使用 SQLite 資料庫來建立新的專案，當然你是可以換的。

這裡是一段有連線資訊的開發用預設設定檔(<tt>config/database.yml</tt>)：

<yaml>
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000
</yaml>

NOTE: 本指南使用 SQLite3 資料庫，因為它完全不需要什麼設定就可以用了。Rails 當然也支援 MySQL 跟 PostgreSQL 可以使用，也有其他資料庫系統的 plugins。如果是正式的上線環境就會需要了。

h5. 設定 MySQL 資料庫

如果你選擇使用 MySQL 取代預設的 Sqlite3 資料庫，你的 +config/database.yml+ 會有點不同，以下是一個開發用的設定檔：

<yaml>
development:
  adapter: mysql
  encoding: utf8
  database: blog_development
  pool: 5
  username: root
  password:
  socket: /tmp/mysql.sock
</yaml>

如果你的開發用電腦的 MySQL 有 root user 和空白密碼，那這個設定就可以用了。不然，請修改 username 和 password。

h5. 設定 PostgreSQL 資料庫

最後，如果你選擇使用 PostgreSQL，你的 +config/database.yml+ 可以設定成:

<yaml>
development:
  adapter: postgresql
  encoding: unicode
  database: blog_development
  pool: 5
  username: blog
  password:
</yaml>

變更 username 和 password 符合你所需。

h4. 建立資料庫

現在你的資料庫設定妥當，是時候讓 Rails 建立空的資料庫了。你可以輸入以下的 rake 指令：

<shell>
$ rake db:create
</shell>

這將在 <tt>db/</tt> 目錄下建立 development 和 test 的 SQLite3 資料庫。

TIP: Rake 是一種通用型的 command 工具，被廣泛運用在 Rails 中。你可以輸入 +rake -T+ 列出所有可用的指令。

h3. 哈囉，Rails!

每學習一個新的程式語言，一開始都會有個輸出 Hello, World! 的最簡單練習。為了辦到這件事情，你需要啟動 Rails 應用程式的伺服器。

h4. 啟動 Web 伺服器

其實你已經有了一個可以運作的 Rails 應用程式了。要在你的開發機上啟動 Web 伺服器，請輸入：

<shell>
$ rails server
</shell>

這將啟動一個 Mongrel (譯註：或是 WEBrick) 伺服器(Rails 也可以用其他的伺服器)。要看到結果，請打開瀏覽器前往 "http://localhost:3000":http://localhost:3000 。你應該會看到 Rails 的預設首頁。

!images/rails_welcome.png(Welcome Aboard screenshot)!

TIP: 要關閉伺服器的話，請輸入 Ctrl+C。在 development mode 開發模式的話，Rails 通常是不需要重新啟動的，修改的檔案會自動載入。(譯註：如果是 production mode 的話，修改任何檔案都必須重新啟動伺服器才會有效果)

這個 "Welcome Aboard" 的畫面是一個 Rails 應用程式的 _煙霧測試(smoke test)_： 它確認了你的軟體設定正確。關於應用程式的摘要環境資訊，你也可以點擊  _About your application’s environment_ 的超連結。

h4. 說 "Hello"，Rails

要讓 Rails 說 "Hello"，你至少必須建立一個 Controller 跟 View。而我們用一個指令就可以辦到了。在命令列視窗輸入：

<shell>
$ rails generate controller home index
</shell>

TIP: 如果你在 Windows 上，或你的 Ruby 不像常見的設定，你可能需要改成輸入 +ruby \path\to\rails controller home index+。

Rails 將會新增幾個檔案，包括 +app/views/home/index.html.erb+。這個樣板(template)會被用來顯示 +home+ controller 裡的 +index+ action (method) 的結果。用編輯器打開這個檔案，加入以下程式碼：

<code class="html">
<h1>Hello, Rails!</h1>
</code>

h4. 設定首頁

那現在我們有了 Controller 跟 View，我們需要告訴 Rails 什麼時候 "Hello Rails" 要出現。在這個例子裡，我們希望把剛剛首頁的 "http://localhost:3000":http://localhost:3000 的 "Welcome Aboard" 換掉，改成 "Hello Rails"

第一步是刪除預設的首頁檔案：

<shell>
$ rm public/index.html
</shell>

這是因為 Rails 會優先回傳任何 +public+ 下有的靜態檔案，而不是 Controllers 裡面建立的動態內容。

接著，你必須要告訴 Rails 你真正的首頁在哪裡。用編輯器打開 +config/routes.rb+ 這個檔案。這是你的應用程式的 _路徑檔案 (routing file)_，它是一個特殊的 DSL (domain-specific language 專屬領域語言) 告訴 Rails 如何將進來的 HTTP 請求連結配對到 Controllers 跟 Actions。這個檔案包含許多註解起來的範例，其中一行開頭是 +:root to+ 請把註解移掉如下：

<ruby>
Blog::Application.routes.draw do

  # You can have the root of your site routed with "root"
  # just remember to delete public/index.html.
  
  root :to => "home#index"
  
</ruby>

+root :to => "home#index"+ 這一行告訴 Rails 將 root 網址配對到 home controller 的 index action。

接下來用瀏覽器打開 "http://localhost:3000":http://localhost:3000 ，你就會看到 +Hello, Rails!+ 了。

NOTE. 關於更多路徑的資訊，請參考 "Rails Routing from the Outside In":routing.html.

h3. 使用鷹架 (scaffolding) 快速上手

Rails 的 _鷹架 (scaffolding)_ 功能可以用一行指令就快速為一個 Resource 建立一組 Model, Views 跟 Controller 的程式碼。

h3. 建立一個 Resource

在這個 blog 的例子，你可以用鷹架建立 Post resource：這將完成一個部落格文章管理功能。要辦到這件事情，在命令列視窗輸入：

<shell>
$ rails generate scaffold Post name:string title:string content:text
</shell>

NOTE. 雖然鷹架(scaffolding)可以幫助你快速上手，但是可沒辦法產生出完美符合需求的程式碼。因此許多有經驗的 Rails 開發者會根本不用鷹架(scaffolding)功能，而偏好從頭打造起 Models, Controllers 和 Views。

鷹架(scaffold)產生器會建立出 15 個檔案在不同目錄，以下是一個簡單的說明：

|_.檔案                                       |_.目的|
|db/migrate/20100207214725_create_posts.rb.rb    |Migration to create the posts table in your database (your name will include a different timestamp)|
|app/models/post.rb                           |The Post model|
|test/fixtures/posts.yml                      |Dummy posts for use in testing|
|app/controllers/posts_controller.rb          |The Posts controller|
|app/views/posts/index.html.erb               |A view to display an index of all posts |
|app/views/posts/edit.html.erb                |A view to edit an existing post|
|app/views/posts/show.html.erb                |A view to display a single post|
|app/views/posts/new.html.erb                 |A view to create a new post|
|app/views/posts/_form.html.erb               |A partial to control the overall look and feel of the form used in edit and new views|
|app/helpers/posts_helper.rb                  |Helper functions to be used from the post views|
|test/unit/post_test.rb                       |Unit testing harness for the posts model|
|test/functional/posts_controller_test.rb     |Functional testing harness for the posts controller|
|test/unit/helpers/posts_helper_test.rb       |Unit testing harness for the posts helper|
|config/routes.rb                             |Edited to include routing information for posts|
|public/stylesheets/scaffold.css              |Cascading style sheet to make the scaffolded views look better|

h4. 執行 Migration

+rails generate scaffold+ 產生出來的程式碼中，有一項是 _資料庫遷移(database migration)_。Migration 是一個 Ruby 的類別用來方便建立和修改資料庫資料表。Rails 使用 rake 指令來執行 migrations，而且它也支援可以逆推剛剛執行的 migration 步驟。Migration 的檔名包含了時間戳章(timestamp)，用來確保它們可以依照建立時間依序執行。

如果你仔細看看 +db/migrate/20100207214725_create_posts.rb+ 這個檔案(記住，你的檔名開頭會有點不一樣)，你將看到：

<ruby>
class CreatePosts < ActiveRecord::Migration
  def self.up
    create_table :posts do |t|
      t.string :name
      t.string :title
      t.text :content

      t.timestamps
    end
  end

  def self.down
    drop_table :posts
  end
end
</ruby>

以上的 Migration 有兩個函式， +up+ 會在 migration 進資料庫時執行，而 +down+ 則會在之後需要逆推的時候執行。在這個例子中 +up+  會建立 +posts+ 資料表，包含兩個 string 欄位和一個 text 欄位。它也會建立兩個 timestamp 欄位(譯註: t.timestamps 該行等同於 t.datetime :created_at 和 t.datetime :updated_at)用來追蹤建立和最後修改時間。更多的 Rails migrations 資訊請參考 "Rails Database Migrations":migrations.html 。

這時你可以用以下的 rake 指令執行 Migration：

<shell>
$ rake db:migrate
</shell>

Rails 就會執行這個 migration 命令然後告訴你它建立了 Posts 資料表。

<shell>
==  CreatePosts: migrating ====================================================
-- create_table(:posts)
   -> 0.0019s
==  CreatePosts: migrated (0.0020s) ===========================================
</shell>

NOTE. 因為預設是跑在 development 模式，這個指令會套用在 +config/database.yml+ 設定中 +development+ 那段所指定的資料庫。

h4. 增加超連結

為了能把文章列表加到我們已經建好的首頁，你可以增加一個超連結在首頁上。打開 +app/views/home/index.html.erb+ 然後修改成：

<code lang="ruby">
<h1>Hello, Rails!</h1>
<%= link_to "My Blog", posts_path %>
</code>

這個 +link_to+ 函式是 Rails 內建的 view helpers (View 的輔助函式)。它會建立一個文字超連結，連到文章列表。

h4. 在瀏覽器中操作文章

好，你已經準備可以進入文章列表了，請瀏覽 "http://localhost:3000":http://localhost:3000/ 然後點擊 "My Blog" 連結：

!images/posts_index.png(Posts Index screenshot)!

這就是 Rails 執行 +index+ view 文章頁面的結果。目前資料庫裡面還沒有任何文章，如果你點選 +New Post+ 連結，就可以新增一篇。有了文章之後，你就可以編輯、詳細瀏覽或刪除。所有的邏輯和 HTML 都被內建的 +rails generate scaffold+ 指令搞定了。

TIP: 在 development 模式中(也就是目前的預設環境)，Rails 每次瀏覽器來 HTTP 請求都會重新載入程式，所以不需要重新啟動伺服器。

恭喜啦，你正在駕馭 Rails! 現在讓我們看看到底它是如何運作的。

h4. Model

+app/models/post.rb+ 就是 Model 檔案，它非常簡單：

<ruby>
class Post < ActiveRecord::Base
end
</ruby>

程式碼不多，但是注意 +Post+ 類別繼承了 +ActiveRecord::Base+。Active Record 讓你的 Model 有非常多的功能，包括基本的資料庫 CRUD 操作(Create, Read, Update, Destroy，新增、瀏覽、更新、刪除)、資料驗證(data validation)、厲害的搜尋以及可以跟其他 Models 關連在一起。

h4. 新增一些 Validation (驗證)

Rails 提供一些函式幫助你驗證資料的正確性，編輯 +app/models/post.rb+ 這個檔案:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }
end
</ruby>

這幾行程式會確保所有儲存的文章一定會有 name 和 title 的資料，而且 title 至少有五個字元長度。Rails 提供各種驗證的方法，包括必填、唯一性、格式或是需要有關連物件。

h4. 使用 Console 主控台

要看到 validations 的作用，你可以使用 console。console 是一個命令列工具可以讓你在 Rails 中的環境中執行 Ruby 程式：

<shell>
$ rails console
</shell>

在 console 載入之後，你就可以在裡面使用 Models：

<shell>
>> p = Post.new(:content => "A new post")
=> #<Post id: nil, name: nil, title: nil, 
     content: "A new post", created_at: nil,
     updated_at: nil>
>> p.save
=> false
>> p.errors
=> #<OrderedHash { :title=>["can't be blank", 
                           "is too short (minimum is 5 characters)"],
                   :name=>["can't be blank"] }>
</shell>

這段程式先建立一個 +Post+ 實例，試圖要儲存進資料庫，但是卻回傳一個 +false+ (表示儲存失敗)，然後觀察文章的 +errors+。

TIP: 不像在 development 模式，console 不會自動載入剛修改的程式。如果你在 console 開啟之後才修改程式，請輸入 +reload!+ 重新載入。

h4. 列出所有文章

最容易開始了解的地方就是列出文章的程式碼。打開 +app/controllers/posts_controller.rb 這個檔案然後看 +index+ 這個 action:

<ruby>
def index
  @posts = Post.all

  respond_to do |format|
    format.html # index.html.erb
    format.xml  { render :xml => @posts }
  end
end
</ruby>

+Post.all+ 會呼叫 +Post+ model 回傳資料庫裡面目前所有的文章。結果會是一個包含文章的 @posts 陣列。

TIP: 關於更多 Active Reocrd 資料查詢的功能，請查閱 "Active Record Query Interface":active_record_querying.html.

這個 +respond_to+ 的區塊同時處理了 HTML 和 XML 的請求。如果瀏覽器瀏覽 "http://localhost:3000/posts.xml":http://localhost:3000/posts.xml 你就會看到 XML 格式。HTML 格式會去找 +app/views/posts/+ 下符合 action 名稱的檔案。Rails 會讓所有 action 裡的實例變數(instance variables)(譯註: 也就是有 @ 開頭的變數) 通通傳到 View 裡面也可以使用。以下是 +app/views/posts/index.html.erb+:

<erb>
<h1>Listing posts</h1>

<table>
  <tr>
    <th>Name</th>
    <th>Title</th>
    <th>Content</th>
    <th></th>
    <th></th>
    <th></th>
  </tr>

<% @posts.each do |post| %>
  <tr>
    <td><%= post.name %></td>
    <td><%= post.title %></td>
    <td><%= post.content %></td>
    <td><%= link_to 'Show', post %></td>
    <td><%= link_to 'Edit', edit_post_path(post) %></td>
    <td><%= link_to 'Destroy', post, :confirm => 'Are you sure?', :method => :delete %></td>
  </tr>
<% end %>
</table>

<br />

<%= link_to 'New post', new_post_path %>
</erb>

這個 view 迭代了 +@posts+ 陣列並顯示內容跟連結，有幾件值得注意的事情：

* +link_to+ 建立超連結到一個特定的位置
* +edit_post_path+ 和 +new_post_path+ 都是 Rails RESTful 路徑的 helpers。你也會在 controller 的不同 actions 中看到這些 helpers。

NOTE. 在之前的 Rails 版本，你必須使用 +&lt;%=h post.name %&gt;+ 如此 HTML 才會被逸出(譯註：可以防止 "XSS":http://zh.wikipedia.org/zh/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC 網路攻擊)。在 Raisl 3.0 中預設就會逸出。如果不要逸出，請使用 +&lt;%= raw post.name %&gt;+ 。

TIP: 關於更多 rendering 的處理，請參閱 "Layouts and Rendering in Rails":layouts_and_rendering.html.

h4. 客製化 Layout 版型

The view is only part of the story of how HTML is displayed in your web browser. Rails also has the concept of +layouts+, which are containers for views. When Rails renders a view to the browser, it does so by putting the view's HTML into a layout's HTML. In previous versions of Rails, the +rails generate scaffold+ command would automatically create a controller specific layout, like +app/views/layouts/posts.html.erb+, for the posts controller. However this has been changed in Rails 3.0. A application specific +layout+ is used for all the controllers and can be found in +app/views/layouts/application.html.erb+. Open this layout in your editor and modify the +body+ tag:

<erb>
<!DOCTYPE html>
<html>
<head>
  <title>Blog</title>
  <%= stylesheet_link_tag :all %>
  <%= javascript_include_tag :defaults %>
  <%= csrf_meta_tag %>
</head>
<body style="background: #EEEEEE;">

<%= yield %>

</body>
</html>
</erb>

Now when you refresh the +/posts+ page, you'll see a gray background to the page. This same gray background will be used throughout all the views for posts.

h4. 建立新文章

Creating a new post involves two actions. The first is the +new+ action, which instantiates an empty +Post+ object:

<ruby>
def new
  @post = Post.new

  respond_to do |format|
    format.html # new.html.erb
    format.xml  { render :xml => @post }
  end
end
</ruby>

The +new.html.erb+ view displays this empty Post to the user:

<erb>
<h1>New post</h1>

<%= render 'form' %>

<%= link_to 'Back', posts_path %>
</erb>

The +&lt;%= render 'form' %&gt;+ line is our first introduction to _partials_ in Rails.  A partial is a snippet of HTML and Ruby code that can be reused in multiple locations.  In this case, the form used to make a new post, is basically identical to a form used to edit a post, both have text fields for the name and title and a text area for the content with a button to make a new post or update the existing post.

If you take a look at +views/posts/_form.html.erb+ file, you will see the following:

<erb>
<%= form_for(@post) do |f| %>
  <% if @post.errors.any? %>
  <div id="errorExplanation">
    <h2><%= pluralize(@post.errors.count, "error") %> prohibited this post from being saved:</h2>
    <ul>
    <% @post.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
  <% end %>

  <div class="field">
    <%= f.label :name %><br />
    <%= f.text_field :name %>
  </div>
  <div class="field">
    <%= f.label :title %><br />
    <%= f.text_field :title %>
  </div>
  <div class="field">
    <%= f.label :content %><br />
    <%= f.text_area :content %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>
</erb>

This partial receives all the instance variables defined in the calling view file, so in this case, the controller assigned the new Post object to +@post+ and so, this is available in both the view and partial as +@post+.

For more information on partials, refer to the "Layouts and Rendering in Rails":layouts_and_rendering.html#using-partials guide.

The +form_for+ block is used to create an HTML form. Within this block, you have access to methods to build various controls on the form. For example, +f.text_field :name+ tells Rails to create a text input on the form, and to hook it up to the +name+ attribute of the instance being displayed. You can only use these methods with attributes of the model that the form is based on (in this case +name+, +title+, and +content+). Rails uses +form_for+ in preference to having you write raw HTML because the code is more succinct, and because it explicitly ties the form to a particular model instance.

The +form_for+ block is also smart enough to work out if you are doing a _New Post_ or an _Edit Post_ action, and will set the form +action+ tags and submit button names appropriately in the HTML output.

TIP: If you need to create an HTML form that displays arbitrary fields, not tied to a model, you should use the +form_tag+ method, which provides shortcuts for building forms that are not necessarily tied to a model instance.

When the user clicks the +Create Post+ button on this form, the browser will send information back to the +create+ method of the controller (Rails knows to call the +create+ method because the form is sent with an HTTP POST request; that's one of the conventions that I mentioned earlier):

<ruby>
def create
  @post = Post.new(params[:post])

  respond_to do |format|
    if @post.save
      format.html { redirect_to(@post,
                    :notice => 'Post was successfully created.') }
      format.xml  { render :xml => @post,
                    :status => :created, :location => @post }
    else
      format.html { render :action => "new" }
      format.xml  { render :xml => @post.errors,
                    :status => :unprocessable_entity }
    end
  end
end
</ruby>

The +create+ action instantiates a new Post object from the data supplied by the user on the form, which Rails makes available in the +params+ hash. After successfully saving the new post, +create+ returns the appropriate format that the user has requested (HTML in our case). It then redirects the user to the resulting post +show+ action and sets a notice to the user that the Post was successfully created.

If the post was not successfully saved, due to a validation error, then the controller returns the user back to the +new+ action with any error messages so that the user has the chance to fix the error and try again.

The "Post was successfully created" message is stored inside of the Rails +flash+ hash, (usually just called the Flash) so that messages can be carried over to another action, providing the user with useful information on the status of their request. In the case of +create+, the user never actually sees any page rendered during the Post creation process, because it immediately redirects to the new Post as soon Rails saves the record. The Flash carries over a message to the next action, so that when the user is redirected back to the +show+ action, they are presented with a message saying "Post was successfully created."

h4. 顯示個別文章

When you click the +show+ link for a post on the index page, it will bring you to a URL like +http://localhost:3000/posts/1+. Rails interprets this as a call to the +show+ action for the resource, and passes in +1+ as the +:id+ parameter. Here's the +show+ action:

<ruby>
def show
  @post = Post.find(params[:id])

  respond_to do |format|
    format.html # show.html.erb
    format.xml  { render :xml => @post }
  end
end
</ruby>

The +show+ action uses +Post.find+ to search for a single record in the database by its id value. After finding the record, Rails displays it by using +show.html.erb+:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>


<%= link_to 'Edit', edit_post_path(@post) %> |
<%= link_to 'Back', posts_path %>
</erb>

h4. Editing Posts

Like creating a new post, editing a post is a two-part process. The first step is a request to +edit_post_path(@post)+ with a particular post. This calls the +edit+ action in the controller:

<ruby>
def edit
  @post = Post.find(params[:id])
end
</ruby>

After finding the requested post, Rails uses the +edit.html.erb+ view to display it:

<erb>
<h1>Editing post</h1>

<%= render 'form' %>

<%= link_to 'Show', @post %> |
<%= link_to 'Back', posts_path %>
<% end %>
</erb>

Again, as with the +new+ action, the +edit+ action is using the +form+ partial, this time however, the form will do a PUT action to the PostsController and the submit button will display "Update Post"

Submitting the form created by this view will invoke the +update+ action within the controller:

<ruby>
def update
  @post = Post.find(params[:id])

  respond_to do |format|
    if @post.update_attributes(params[:post])
      format.html { redirect_to(@post, 
                    :notice => 'Post was successfully updated.') }
      format.xml  { head :ok }
    else
      format.html { render :action => "edit" }
      format.xml  { render :xml => @post.errors,
                    :status => :unprocessable_entity }
    end
  end
end
</ruby>

In the +update+ action, Rails first uses the +:id+ parameter passed back from the edit view to locate the database record that's being edited. The +update_attributes+ call then takes the rest of the parameters from the request and applies them to this record. If all goes well, the user is redirected to the post's +show+ view. If there are any problems, it's back to the +edit+ view to correct them.

h4. 刪除文章

Finally, clicking one of the +destroy+ links sends the associated id to the +destroy+ action:

<ruby>
def destroy
  @post = Post.find(params[:id])
  @post.destroy

  respond_to do |format|
    format.html { redirect_to(posts_url) }
    format.xml  { head :ok }
  end
end
</ruby>

The +destroy+ method of an Active Record model instance removes the corresponding record from the database. After that's done, there isn't any record to display, so Rails redirects the user's browser to the index view for the model.

h3. 新增第二個 Model

Now that you've seen how a model built with scaffolding looks like, it's time to add a second model to the application. The second model will handle comments on blog posts.

h4. 產生 Model

Models in Rails use a singular name, and their corresponding database tables use a plural name. For the model to hold comments, the convention is to use the name Comment. Even if you don't want to use the entire apparatus set up by scaffolding, most Rails developers still use generators to make things like models and controllers. To create the new model, run this command in your terminal:

<shell>
$ rails generate model Comment commenter:string body:text post:references
</shell>

This command will generate four files:

* +app/models/comment.rb+ - The model
* +db/migrate/20100207235629_create_comments.rb+ - The migration
* +test/unit/comment_test.rb+ and +test/fixtures/comments.yml+ - The test harness.

First, take a look at +comment.rb+:

<ruby>
class Comment < ActiveRecord::Base
  belongs_to :post
end
</ruby>

This is very similar to the +post.rb+ model that you saw earlier. The difference is the line +belongs_to :post+, which sets up an Active Record _association_. You'll learn a little about associations in the next section of this guide.

In addition to the model, Rails has also made a migration to create the corresponding database table:

<ruby>
class CreateComments < ActiveRecord::Migration
  def self.up
    create_table :comments do |t|
      t.string :commenter
      t.text :body
      t.references :post

      t.timestamps
    end
  end

  def self.down
    drop_table :comments
  end
end
</ruby>

The +t.references+ line sets up a foreign key column for the association between the two models. Go ahead and run the migration:

<shell>
$ rake db:migrate
</shell>

Rails is smart enough to only execute the migrations that have not already been run against the current database, so in this case you will just see:

<shell>
==  CreateComments: migrating =================================================
-- create_table(:comments)
   -> 0.0017s
==  CreateComments: migrated (0.0018s) ========================================
</shell>

h4. 把 Models 關連起來

Active Record associations let you easily declare the relationship between two models. In the case of comments and posts, you could write out the relationships this way:

* Each comment belongs to one post
* One post can have many comments

In fact, this is very close to the syntax that Rails uses to declare this association. You've already seen the line of code inside the Comment model that makes each comment belong to a Post:

<ruby>
class Comment < ActiveRecord::Base
  belongs_to :post
end
</ruby>

You'll need to edit the +post.rb+ file to add the other side of the association:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }

  has_many :comments
end
</ruby>

These two declarations enable a good bit of automatic behavior. For example, if you have an instance variable +@post+ containing a post, you can retrieve all the comments belonging to that post as the array +@post.comments+.

TIP: For more information on Active Record associations, see the "Active Record Associations":association_basics.html guide.

h4. 為留言新增一個 URL 路徑

As with the +home+ controller, we will need to add a route so that Rails knows where we would like to navigate to see +comments+.  Open up the +config/routes.rb+ file again, you will see an entry that was added automatically for +posts+ near the top by the scaffold generator, +resources :posts+, edit it as follows:

<ruby>
resources :posts do
  resources :comments
end
</ruby>

This creates +comments+ as a _nested resource_ within +posts+. This is another part of capturing the hierarchical relationship that exists between posts and comments.

TIP: For more information on routing, see the "Rails Routing from the Outside In":routing.html guide.

h4.產生一個 Controller

With the model in hand, you can turn your attention to creating a matching controller. Again, there's a generator for this:

<shell>
$ rails generate controller Comments
</shell>

This creates four files and one empty directory:

* +app/controllers/comments_controller.rb+ - The controller
* +app/helpers/comments_helper.rb+ - A view helper file
* +test/functional/comments_controller_test.rb+ - The functional tests for the controller
* +test/unit/helpers/comments_helper_test.rb+ - The unit tests for the helper
* +app/views/comments/+ - Views of the controller are stored here

Like with any blog, our readers will create their comments directly after reading the post, and once they have added their comment, will be sent back to the post show page to see their comment now listed.  Due to this, our +CommentsController+ is there to provide a method to create comments and delete SPAM comments when they arrive.

So first, we'll wire up the Post show template (+/app/views/posts/show.html.erb+) to let us make a new comment:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Add a comment:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <%= f.error_messages %>

  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

This adds a form on the Post show page that creates a new comment, which will call the +CommentsController+ +create+ action, so let's wire that up:

<ruby>
class CommentsController < ApplicationController
  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.create(params[:comment])
    redirect_to post_path(@post)
  end
end
</ruby>

You'll see a bit more complexity here than you did in the controller for posts. That's a side-effect of the nesting that you've set up; each request for a comment has to keep track of the post to which the comment is attached, thus the initial find action to the Post model to get the post in question.

In addition, the code takes advantage of some of the methods available for an association. We use the +create+ method on +@post.comments+ to create and save the comment. This will automatically link the comment so that it belongs to that particular post.

Once we have made the new comment, we send the user back to the original post using the +post_path(@post)+ helper. As we have already seen, this calls the +show+ action of the +PostsController+ which in turn renders the +show.html.erb+ template. This is where we want the comment to show, so let's add that to the +app/views/posts/show.html.erb+.

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Comments</h2>
<% @post.comments.each do |comment| %>
  <p>
    <b>Commenter:</b>
    <%= comment.commenter %>
  </p>

  <p>
    <b>Comment:</b>
    <%= comment.body %>
  </p>
<% end %>

<h2>Add a comment:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <%= f.error_messages %>

  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<br />

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

Now you can add posts and comments to your blog and have them show up in the right places.

h3. Refactorization

Now that we have Posts and Comments working, if we take a look at the +app/views/posts/show.html.erb+ template, it's getting long and awkward. We can use partials to clean this up.

h4. Rendering Partial Collections

First we will make a comment partial to extract showing all the comments for the post. Create the file +app/views/comments/_comment.html.erb+ and put the following into it:

<erb>
<p>
  <b>Commenter:</b>
  <%= comment.commenter %>
</p>

<p>
  <b>Comment:</b>
  <%= comment.body %>
</p>
</erb>

Then in the +app/views/posts/show.html.erb+ you can change it to look like the following:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Comments</h2>
<%= render :partial => "comments/comment", 
           :collection => @post.comments %>

<h2>Add a comment:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <%= f.error_messages %>

  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<br />

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

This will now render the partial in +app/views/comments/_comment.html.erb+ once for each comment that is in the +@post.comments+ collection.  As the +render+ method iterates over the <tt>@post.comments</tt> collection, it assigns each comment to a local variable named the same as the partial, in this case +comment+ which is then available in the partial for us to show.

h4. Rendering a Partial Form

Lets also move that new comment section out to it's own partial, again, you create a file +app/views/comments/_form.html.erb+ and in it you put:

<erb>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <%= f.error_messages %>

  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>
</erb>

Then you make the +app/views/posts/show.html.erb+ look like the following:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Comments</h2>
<%= render :partial => "comments/comment", 
           :collection => @post.comments %>

<h2>Add a comment:</h2>
<%= render "comments/form" %>

<br />

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

The second render just defines the partial template we want to render, <tt>comments/form</tt>, Rails is smart enough to spot the forward slash in that string and realise that you want to render the <tt>_form.html.erb</tt> file in the <tt>app/views/comments</tt> directory.

The +@post+ object is available to any partials rendered in the view because we defined it as an instance variable.

h3. Deleting Comments

Another important feature on a blog is being able to delete SPAM comments.  To do this, we need to implement a link of some sort in the view and a +DELETE+ action in the +CommentsController+.

So first, let's add the delete link in the +app/views/comments/_comment.html.erb+ partial:

<erb>
<p>
  <b>Commenter:</b>
  <%= comment.commenter %>
</p>

<p>
  <b>Comment:</b>
  <%= comment.body %>
</p>

<p>
  <%= link_to 'Destroy Comment', [comment.post, comment],
               :confirm => 'Are you sure?',
               :method => :delete %>
</p>
</erb>

Clicking this new "Destroy Comment" link will fire off a <tt>DELETE /posts/:id/comments/:id</tt> to our +CommentsController+, which can then use this to find the comment we want to delete, so let's add a destroy action to our controller:

<ruby>
class CommentsController < ApplicationController

  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.create(params[:comment])
    redirect_to post_path(@post)
  end

  def destroy
    @post = Post.find(params[:post_id])
    @comment = @post.comments.find(params[:id])
    @comment.destroy
    redirect_to post_path(@post)
  end

end
</ruby>

The +destroy+ action will find the post we are looking at, locate the comment within the <tt>@post.comments</tt> collection, and then remove it from the database and send us back to the show action for the post.


h4. 刪除關連的物件

If you delete a post then its associated comments will also need to be deleted. Otherwise they would simply occupy space in the database. Rails allows you to use the +dependent+ option of an association to achieve this. Modify the Post model, +app/models/post.rb+, as follows:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }
  has_many :comments, :dependent => :destroy
end
</ruby>

h3. 安全性

If you were to publish your blog online, anybody would be able to add, edit and delete posts or delete comments.

Rails provides a very simple HTTP authentication system that will work nicely in this situation. First, we enable simple HTTP based authentication in our <tt>app/controllers/application_controller.rb</tt>:

<ruby>
class ApplicationController < ActionController::Base
  protect_from_forgery
  
  private
  
  def authenticate
    authenticate_or_request_with_http_basic do |user_name, password|
      user_name == 'admin' && password == 'password'
    end
  end
  
end
</ruby>

You can obviously change the username and password to whatever you want.  We put this method inside of +ApplicationController+ so that it is available to all of our controllers.

Then in the +PostsController+ we need to have a way to block access to the various actions if the person is not authenticated, here we can use the Rails <tt>before_filter</tt> method, which allows us to specify that Rails must run a method and only then allow access to the requested action if that method allows it.

To use the before filter, we specify it at the top of our +PostsController+, in this case, we want the user to be authenticated on every action, except for +index+ and +show+, so we write that:

<ruby>
class PostsController < ApplicationController

  before_filter :authenticate, :except => [:index, :show]

  # GET /posts
  # GET /posts.xml
  def index
    @posts = Post.all
    respond_to do |format|
# snipped for brevity
</ruby>

We also only want to allow authenticated users to delete comments, so in the +CommentsController+ we write:

<ruby>
class CommentsController < ApplicationController

  before_filter :authenticate, :only => :destroy

  def create
    @post = Post.find(params[:post_id])
# snipped for brevity
</ruby>

Now if you try to create a new post, you will be greeted with a basic HTTP Authentication challenge

!images/challenge.png(Basic HTTP Authentication Challenge)!


h3. 建立一個有多重 Model 的表單

Another feature of your average blog is the ability to tag posts. To implement this feature your application needs to interact with more than one model on a single form. Rails offers support for nested forms.

To demonstrate this, we will add support for giving each post multiple tags, right in the form where you create the post. First, create a new model to hold the tags:

<shell>
$ rails generate model tag name:string post:references
</shell>

Again, run the migration to create the database table:

<shell>
$ rake db:migrate
</shell>

Next, edit the +post.rb+ file to create the other side of the association, and to tell Rails (via the +accepts_nested_attributes+ macro) that you intend to edit tags via posts:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }

  has_many :comments, :dependent => :destroy
  has_many :tags

  accepts_nested_attributes_for :tags, :allow_destroy => :true,
    :reject_if => proc { |attrs| attrs.all? { |k, v| v.blank? } }
end
</ruby>

The +:allow_destroy+ option on the nested attribute declaration tells Rails to display a "remove" checkbox on the view that you'll build shortly. The +:reject_if+ option prevents saving new tags that do not have any attributes filled in.

We will modify +views/posts/_form.html.erb+ to render a partial to make a tag:

<erb>
<% @post.tags.build %>
<%= form_for(@post) do |post_form| %>
  <% if @post.errors.any? %>
  <div id="errorExplanation">
    <h2><%= pluralize(@post.errors.count, "error") %> prohibited this post from being saved:</h2>
    <ul>
    <% @post.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
  <% end %>

  <div class="field">
    <%= post_form.label :name %><br />
    <%= post_form.text_field :name %>
  </div>
  <div class="field">
    <%= post_form.label :title %><br />
    <%= post_form.text_field :title %>
  </div>
  <div class="field">
    <%= post_form.label :content %><br />
    <%= post_form.text_area :content %>
  </div>
  <h2>Tags</h2>
  <%= render :partial => 'tags/form',
             :locals => {:form => post_form} %>
  <div class="actions">
    <%= post_form.submit %>
  </div>
<% end %>
</erb>

Note that we have changed the +f+ in +form_for(@post) do |f|+ to +post_form+ to make it easier to understand what is going on.

This example shows another option of the render helper, being able to pass in local variables, in this case, we want the local variable +form+ in the partial to refer to the +post_form+ object.

We also add a <tt>@post.tags.build</tt> at the top of this form, this is to make sure there is a new tag ready to have it's name filled in by the user.  If you do not build the new tag, then the form will not appear as there is no new Tag object ready to create.

Now create the folder <tt>app/views/tags</tt> and make a file in there called <tt>_form.html.erb</tt> which contains the form for the tag:

<erb>
<%= form.fields_for :tags do |tag_form| %>
  <div class="field">
    <%= tag_form.label :name, 'Tag:' %>
    <%= tag_form.text_field :name %>
  </div>
  <% unless tag_form.object.nil? || tag_form.object.new_record? %>
    <div class="field">
      <%= tag_form.label :_destroy, 'Remove:' %>
      <%= tag_form.check_box :_destroy %>
    </div>
  <% end %>
<% end %>
</erb>

Finally, we will edit the <tt>app/views/posts/show.html.erb</tt> template to show our tags.

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<p>
  <b>Tags:</b>
  <%= @post.tags.map { |t| t.name }.join(", ") %>
</p>

<h2>Comments</h2>
<%= render :partial => "comments/comment", 
           :collection => @post.comments %>

<h2>Add a comment:</h2>
<%= render "comments/form" %>


<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

With these changes in place, you'll find that you can edit a post and its tags directly on the same view.

However, that method call <tt>@post.tags.map { |t| t.name }.join(", ")</tt> is awkward, we could handle this by making a helper method.

h3. View Helpers

View Helpers live in <tt>app/helpers</tt> and provide small snippets of reusable code for views.  In our case, we want a method that strings a bunch of objects together using their name attribute and joining them with a comma.  As this is for the Post show template, we put it in the PostsHelper.

Open up <tt>app/helpers/posts_helper.rb</tt> and add the following:

<erb>
module PostsHelper
  def join_tags(post)
    post.tags.map { |t| t.name }.join(", ") 
  end
end
</erb>

Now you can edit the view in <tt>app/views/posts/show.html.erb</tt> to look like this:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<p>
  <b>Tags:</b>
  <%= join_tags(@post) %>
</p>

<h2>Comments</h2>
<%= render :partial => "comments/comment", 
           :collection => @post.comments %>

<h2>Add a comment:</h2>
<%= render "comments/form" %>


<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

h3. 接下來？

Now that you've seen your first Rails application, you should feel free to update it and experiment on your own. But you don't have to do everything without help. As you need assistance getting up and running with Rails, feel free to consult these support resources:

* The "Ruby On Rails guides":index.html
* The "Ruby on Rails mailing list":http://groups.google.com/group/rubyonrails-talk
* The "#rubyonrails":irc://irc.freenode.net/#rubyonrails channel on irc.freenode.net
* The "Rails Wiki":http://wiki.rubyonrails.org/

Rails also comes with built-in help that you can generate using the rake command-line utility:

* Running +rake doc:guides+ will put a full copy of the Rails Guides in the +doc/guides+ folder of your application. Open +doc/guides/index.html+ in your web browser to explore the Guides.
* Running +rake doc:rails+ will put a full copy of the API documentation for Rails in the +doc/api+ folder of your application. Open +doc/api/index.html+ in your web browser to explore the API documentation.

h3. 設定上的一些訣竅

The easiest way to work with Rails is to store all external data as UTF-8. If you don't, Ruby libraries and Rails will often be able to convert your native data into UTF-8, but this doesn't always work reliably, so you're better off ensuring that all external data is UTF-8.

If you have made a mistake in this area, the most common symptom is a black diamond with a question mark inside appearing in the browser. Another common symptom is characters like "Ã¼" appearing instead of "ü". Rails takes a number of internal steps to mitigate common causes of these problems that can be automatically detected and corrected. However, if you have external data that is not stored as UTF-8, it can occasionally result in these kinds of issues that cannot be automatically detected by Rails and corrected.

Two very common sources of data that are not UTF-8:
* Your text editor: Most text editors (such as Textmate), default to saving files as
  UTF-8. If your text editor does not, this can result in special characters that you
  enter in your templates (such as é) to appear as a diamond with a question mark inside
  in the browser. This also applies to your I18N translation files.
  Most editors that do not already default to UTF-8 (such as some versions of
  Dreamweaver) offer a way to change the default to UTF-8. Do so.
* Your database. Rails defaults to converting data from your database into UTF-8 at
  the boundary. However, if your database is not using UTF-8 internally, it may not
  be able to store all characters that your users enter. For instance, if your database
  is using Latin-1 internally, and your user enters a Russian, Hebrew, or Japanese
  character, the data will be lost forever once it enters the database. If possible,
  use UTF-8 as the internal storage of your database.

h3. 文件修改記錄

"Lighthouse ticket":http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/2

* July 12, 2010: Fixes, editing and updating of code samples by "Jaime Iniesta":http://jaimeiniesta.com
* May 16, 2010: Added a section on configuration gotchas to address common encoding problems that people might have by "Yehuda Katz":http://www.yehudakatz.com
* April 30, 2010: Fixes, editing and updating of code samples by "Rohit Arondekar":http://rohitarondekar.com
* April 25, 2010: Couple of more minor fixups "Mikel Lindsaar":credits.html#raasdnil
* April 1, 2010: Fixed document to validate XHTML 1.0 Strict. "Jaime Iniesta":http://jaimeiniesta.com
* February 8, 2010: Full re-write for Rails 3.0-beta, added helpers and before_filters, refactored code by "Mikel Lindsaar":credits.html#raasdnil
* January 24, 2010: Re-write for Rails 3.0 by "Mikel Lindsaar":credits.html#raasdnil
* July 18, 2009: Minor cleanup in anticipation of Rails 2.3.3 by "Mike Gunderloy":credits.html#mgunderloy
* February 1, 2009: Updated for Rails 2.3 by "Mike Gunderloy":credits.html#mgunderloy
* November 3, 2008: Formatting patch from Dave Rothlisberger
* November 1, 2008: First approved version by "Mike Gunderloy":credits.html#mgunderloy
* October 16, 2008: Revised based on feedback from Pratik Naik by "Mike Gunderloy":credits.html#mgunderloy (not yet approved for publication)
* October 13, 2008: First complete draft by "Mike Gunderloy":credits.html#mgunderloy (not yet approved for publication)
* October 12, 2008: More detail, rearrangement, editing by "Mike Gunderloy":credits.html#mgunderloy (not yet approved for publication)
* September 8, 2008: initial version by "James Miller":credits.html#bensie (not yet approved for publication)

h3. 關於譯者

張文鈿 (a.k.a. "ihower":http://ihower.tw/blog/) 於 July, 2010

h3. 翻譯詞彙

本文翻譯自 "http://guides.rails.info/getting_started.html":http://guides.rails.info/getting_started.html ，以下是英文與繁體中文的對照詞彙：

|_.原文|_.中文|
| model, controller, view, migration, RESTful | 不譯，保留原名詞 |
| action | 指 controller 的 action 時，不譯 |
| view helper (View 輔助函式) | 保留原名詞 |
| development, test, production mode | 指 Rails 運行環境時，不譯 |
| class | 類別 |
| object | 物件 |
| instance | 實例 |
| inherit | 繼承 |
| interface | 介面 |
| library | 函式庫 |
| server | 伺服器 |
| database | 資料庫 |
| (database) table | 資料表 |
| code | 程式碼 |
| command-line | 命令列 |
| method | 函式 |
| application | 應用程式 |
| framework | 框架 |
| template | 樣板 |
| layout | 版型 |
| template rendering | 樣板演算顯示 |
| request | HTTP 請求 |
| scaffolding, scaffold | 鷹架 |
| timestamp | 時間戳章 |
| validation (驗證) | 保留原名詞 |
| callback (回呼) | 保留原名詞 |
| console (主控台) | 保留原名詞 |
| form | 表單 |
| array | 陣列 |
| block | 區塊 |
| iterate | 迭代 |
| escaped | 逸出 |